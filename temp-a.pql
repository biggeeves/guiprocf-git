|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| Creator:   Greg Neils
| Created:   1/01/2007
| Updated:   about every 3 months
| Called by: When a SIR session starts without a DB
| Reason:    Display a list of DBs to connect to.
print back noremarks nocommands user
GCOMPUTE COMMENT = '| '
attribute POISON    filename = '<GDATA4>DCC\ATC\POISON.log'
attribute MST_BAD   filename = '<GDATA4>DCC\ATC\MST_BAD.txt'
attribute MST_FIXED filename = '<GDATA4>DCC\ATC\MST_FIXED.txt'
attribute LOCK_DBS  filename = '<GDATA4>DCC\ATC\LOCKED_DBS.log'
|
|
program crwarn
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 ID_00002                        ; preset ID_00002                         (1 )
integer*1 CUR_DBS$                        ; preset CUR_DBS$                         (2 )
integer*1 DB_PATH                         ; preset DB_PATH                          (3 )
integer*1 MST_NUM#                        ; preset MST_NUM#                         (4 )
integer*1 CUR_DBS                         ; preset CUR_DBS                          (5 )
integer*1 DB_NAME                         ; preset DB_NAME                          (6 )
integer*1 SET_DB_PROC                        ; preset SET_DB_PROC                         (7 )
integer*1 DB_NONE                         ; preset DB_NONE                          (8 )
integer*1 READ_WARN                       ; preset READ_WARN                        (9 )
integer*1 CLEAR_WARN                      ; preset CLEAR_WARN                       (10 )
integer*1 LOCK_DB                         ; preset LOCK_DB                          (11 )
integer*1 LOCK_READ                       ; preset LOCK_READ                        (12 )
integer*1 LOCK_ALL                        ; preset LOCK_ALL                         (13 )
integer*1 LOCK_LIST                       ; preset LOCK_LIST                        (14 )
integer*1 LOCK_LAB                        ; preset LOCK_LAB                         (15 )
integer*1 DBA_NOTE                        ; preset DBA_NOTE                         (16 )
integer*1 LINE2AA                         ; preset LINE2AA                          (17 )
integer*1 LINE3AA                         ; preset LINE3AA                          (18 )
integer*1 LINE1AA                         ; preset LINE1AA                          (19 )
integer*1 LINE4AA                         ; preset LINE4AA                          (20 )
integer*1 USERSTATS                       ; preset USERSTATS                        (21 )

|{ Prologue
|}

dialog "Connect to your database"

|{ Controls
postype 1
line     ID_00002                        ,   0, 268,   0, 509
label    CUR_DBS$                        ,  76,       18,  80, "Already connected to..."
label    DB_PATH                         , 242,      156, 148, "Changes...............sadfasfaffadsf"
label    MST_NUM#                        , 252,      156, 148, "Master#"
list     CUR_DBS                         ,  86,  57,  18,  99, 0
list     DB_NAME                         ,  84, 154, 180, 116, 0
button   SET_DB_PROC                        ,  92,      412,  72, 0, "&DCCPROCF"
button   DB_NONE                         , 110,      412,  72, 0, "SIR"
button   READ_WARN                       , 142,      412,  72, 0, "Read Warnings"
button   CLEAR_WARN                      , 160,      412,  72, 0, "Clear Warnings"
button   LOCK_DB                         , 197,      412,  72, 0, "Lock DBNAME"
button   LOCK_READ                       , 211,      412,  72, 0, "Read Locks"
button   LOCK_ALL                        , 238,      412,  72, 0, "Lock Everything"
list     LOCK_LIST                       , 170,  57,  18,  99, 0
label    LOCK_LAB                        , 159,       18, 100, "Double click to unlock."
label    DBA_NOTE                        ,  62,       18, 146, "Poison Pill Active"
line     LINE2AA                         , 128,   1, 436,  24
line     LINE3AA                         , 178,   1, 436,  24
line     LINE1AA                         ,  86,   1, 436,  24
line     LINE4AA                         , 228,   1, 436,  24
button   USERSTATS                       , 182,      412,  72, 0, "View Usage"
|}

initial
|{ Attribs
|< DBA_NOTE
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#C0C0FF/#000000"
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#C0C0FF/#000000"
|>

|}
|{ Init
string  *  256    STR$1  STR$2                       | helpful to construct strings for execution and messages
integer *    1    DB#                                | ARRAY # corresponding to the DB
string  *   32    MST_IP                             | Master IP address.  Databases can get a specific master IP.
integer *    4    MST_NUM                            | MST_NUM if from the file
integer *    4    CONNSTAT                           | Did the database connect
integer *    1    YESNOVAR                           | Run Sign in first yes no answer
string  *  200    FILE_LINE$                          | lines in the
string  *   10    EXT                                | file extension for a sysproc subroutine
string  *   32    THISUSER                           | USER_NAME
string  *   50    DB_NAME$                           | Name of database
string  *  300    DBPATH SIRPATH CHKPATH             | To find out if it is a DB in the Counting DB.
integer *    2    DUMB_NUM#                          | Use whenever you want to.
integer *    1    ADD_MST                            | Do they need to connect to master
string  *   32    array LOCKED_DB_ARRAY (32)         | Which DBs are locked.
string  *   32    CHECK_DBNAME_LOCK SERVER$          | Name in the text file of the locked or unlocked DB
string  *    8    CHECK_DBSTAT_LOCK                  | Status: LOCKED   or   UNLOCKED
integer *    1    DB_IS_LOCKED                       | 1 = LOCKED... ONLY ADMINS.    0= NOT LOCKED, EVERYONE.
integer *    1    RC                                 | Return code.  -1=cancel; 0 =OK
integer *    1    MST_TRIES                          | How many times to try connecting to master
string  *   32    WHOAREYOU  | ALLOWS US TO CHANGE GLOBAL USERA VALUE
integer *    4    RESVAR
value labels CONNSTAT
  (-2000) ' Bad select value in Host routine'
  (-2001) ' Specified name for database does not match'
  (-2002) ' Invalid password for database'
  (-2003) ' Password needed to attach database'
  (-2004) ' No CIRs/records found within specified restrictions'
  (-2005) ' No more CIRs/records within specified restrictions'
  (-2006) ' Maximum record count exceeded for current CIR'
  (-2008) ' Data file empty'
  (-2009) ' Invalid date string'
  (-2010) ' Invalid time string'
  (-2011) ' No. of days outside valid date range'
  (-2012) ' Data file is full'
  (-2013) ' In use flag set - run VERIFY utility'
  (-2027) ' Data file is empty after last delete'
  (-2028) ' Retrieval update mode required to add new CIR/record'
  (-2029) ' Specified record type locked or undefined'
  (-2030) ' Maximum case limit exceeded - restructure'
  (-2031) ' Data file master index overflow - restructure'
  (-2032) ' Attempted to position beyond end of data file'
  (-2033) ' Database previously opened but not closed'
  (-2034) ' Retrieval update mode required to delete case/record'
  (-2040) ' Cannot open Journal file'
  (-2041) ' Database not initialized'
  (-2042) ' Database closed - must reopen'
  (-2043) ' Invalid Database Reference'
  (-2044) ' Cannot locate update level on reload file'
  (-2045) ' Cannot close database currently used by some stream'
  (-2046) ' Cannot open reload input file'
  (-2047) ' Invalid HOST password specified to use database'
  (-2048) ' Must be DBA to Modify Schema'
  (-2049) ' Invalid lock flag specified'
  (-2053) ' Database already exists'
  (-2054) ' Update level overflow - unload and reload the database'
  (-2055) ' In use by other process'
  (-2056) ' Not found on specified disk'
  (-2057) ' Access forbidden'
  (-2058) ' Problem with open routine'
|
set SHOWATC LIVEACCESS TRAINACCESS DOUBLEACCESS  (0) | just to be on the safe side
set DB#        (0)
set LOCKED_DB_ARRAY * ('0')     | No locks.  It is replaced by DBName if locked
set DB_IS_LOCKED      (0)
|
set item font DB_NAME      ,1,0,0,6,'ARIAL'|BOLD,ITALIC,UNDERL,SIZE,FONT
hide item DBA_NOTE
THISUSER  = '<USERA>'
STR$1 = SIRUSER(THISUSER)
|
<COMMENT> write 'including DB List'
include file DBSLIST
|
execute subprocedure CHECKMASTER
execute subprocedure CHECKPOISON
execute subprocedure SHOWDBS
|
set item LOCK_DB, "Lock " + gettxt(DB_NAME)
execute subprocedure GET_DB#
execute subprocedure GET_MST#
execute subprocedure SHOW_CUR_DBS
execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|
|
set item LOCK_DB, "Lock " + gettxt(DB_NAME)

focus item DB_NAME
|}
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq DB_NAME )
|< DB_NAME
c connects to master and DB and either exits or stay put depending on connection.
. set item LOCK_DB, "Lock " + gettxt(DB_NAME)
. ifthen (nglobal('GSECLEV') ne 1)  | DBAs should never ever be locked out.
.   ifthen (DB_IS_LOCKED eq 1)
.     display infobox 'The database is being updated.  Try back in a few minutes.'
.     NEXT MESSAGE
.   endif
. endif
. execute subprocedure GET_DB#
. execute subprocedure GET_MST#
|>
next message
endif

ifthen (m_id eq SET_DB_PROC )
|< SET_DB_PROC
. execute dbms "set procfile DCCPROCF"
. exit message
|>
next message
endif

ifthen (m_id eq DB_NONE )
|< DB_NONE
exit message
|>
next message
endif

ifthen (m_id eq READ_WARN )
|< READ_WARN
compute STR$1 = 'EDITFILE "' + dsn('MST_BAD')+'"/clear'; EXECUTE DBMS STR$1
|>
next message
endif

ifthen (m_id eq CLEAR_WARN )
|< CLEAR_WARN
ifthen (fileis(dsn('MST_BAD')) ne 1)
. display infobox "Sorry the file was not found"
. next message
endif
. open (MST_BAD) read  lrecl = 500
.   open (MST_FIXED) append lrecl = 500
.     loop
.       read (MST_BAD, end=done) FILE_LINE$ (A200)
.       write (MST_FIXED) FILE_LINE$ (A200)
.     end loop
.     done:
.   close (MST_FIXED)
. close (MST_BAD)

. YESNOVAR = DELFILE (dsn('MST_BAD'))
. ifNOTthen (YESNOVAR eq 0)
.   display infobox "There was an error deleting the file.  Please delete the file by hand"
.   display infobox ["path is:" + dsn('MST_BAD')]
. endif
|>
next message
endif

ifthen (m_id eq LOCK_DB )
|< LOCK_DB
| check master for users, lock database so no more users can get in.
. for DUMB_NUM#=1,getnitem(LOCK_LIST)
.   ifthen (getitxt(LOCK_LIST,DUMB_NUM#) eq gettxt(DB_NAME))
.     display infobox "Look, it is already Locked."
.     next message
.   endif
. end for
. execute subprocedure GET_MST#
. execute subprocedure SET_MST#
. ifthen ( system(69) gt 0)
.   STR$1 = 'Master ' + MST_IP +':' + format(MST_NUM) + ' is attached to ' + format(system(69)) + ' DBs: ' + char(13)
.   for DUMB_NUM# = 1, system(69)
.     STR$1 = STR$1 + char(13)+ getmdbn(DUMB_NUM#)
.   end for
.   display infobox STR$1
. endif
. ifthen (system(68) gt 1)
.   STR$1 = 'Master ' + MST_IP + ':' + format(MST_NUM) + ' has ' + format(system(68)) + ' Clients' + char(13)
.   for DUMB_NUM# = 1, system(68)
.     STR$1 = STR$1 + char(13) + getmcadd(getmclid(DUMB_NUM#))
.     if (getmclst(DUMB_NUM#) ne 0) STR$1 = STR$1 +  '  at  ' + timec(getmclst(DUMB_NUM#), 'hh:mm:ss')
.   end for
.   display infobox STR$1
. endif

. execute dbms "CALL DCCPROCF.BASE.MSTCLEAR"


. STR$1= pad(gettxt(DB_NAME),' ',34,34) + 'LOCKED   ' + datec(today(0),'mm/dd/yyyy')  +'  ' + timec(now(0),'hh:mm ') + THISUSER

. display textbox "Reason?" response YESNOVAR, STR$2
. if (YESNOVAR eq -1) next message | canceled
. if (exists(STR$2) eq 1) STR$1 = STR$1 + '  Reason ' + STR$2
. open  (LOCK_DBS) append iostat= FILE_IOSTAT lrecl=300
.   ifthen (FILE_IOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.   else
.     display infobox 'Error locking database.  DB IS NOT LOCKED.'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST
|>
next message
endif

ifthen (m_id eq LOCK_READ )
|< LOCK_READ
. STR$1 ="EDITFILE '" + dsn('LOCK_DBS') + "'"
. execute dbms STR$1
|>
next message
endif

ifthen (m_id eq LOCK_ALL )
|< LOCK_ALL
. ifthen (fileis(dsn('POISON')) eq 0)
.   display yncbox "Stop everyone from signing in?" response YESNOVAR
.   if (YESNOVAR ne 1) next message  | do not continue
.   STR$1 =  'We expect to be back on-line in 1 hour,'
.   display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   while (exists(STR$1) eq 0)
.     display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   end while
.   set item LOCK_ALL, "Log in Disabled"
.   open (POISON) write
.     write (POISON) 'Nobody can sign in until this file is deleted'
.     write (POISON) 'Created by ' THISUSER | <USERA> ' [upper(getenv('USER_NAME'))]
.     write (POISON) 'Started ' [datec(today(0),'Www. mm/dd/yyyy') ] '  at  '[timec(now(0),'hh:mm pp') ]
.     write (POISON) STR$1
.   close (POISON)
.   show item DBA_NOTE
.   set item DBA_NOTE, "!!!!   NO LOG INS   !!!!!!"

.   display infobox "All access through the ATC have been disabled.  Nobody can sign in."+char(13)+char(13)
                   +"If a user is in a database, they may stay in, but once out, they may not log back in."
. else
.   display yncbox "Allow everyone to sign in through the ATC?" response YESNOVAR
.   ifthen (YESNOVAR eq 1)
.     YESNOVAR = DELFILE (dsn('POISON'))
.     ifthen (YESNOVAR eq 0)
.       display infobox "Everyone may now sign in."
.       set item LOCK_ALL, "Log in Enabled."
.       set item DBA_NOTE, ""
.     else
.       display infobox "There was an error deleting the file. It still exists. No sign ins allowed"
.       display infobox ["path is:" + dsn('POISON')]
.       set item LOCK_ALL, "Log in Disabled."
.       set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.     endif
.   else
.     display infobox "Users are not allowed in."
.     set item LOCK_ALL, "Log in Disabled."
.     set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.   endif
. endif
|>
next message
endif

ifthen (m_id eq LOCK_LIST )
|< LOCK_LIST
. if(M_ARG2 ne 1) NEXT MESSAGE
. STR$1 = pad(gettxt(LOCK_LIST),' ',34,34) + 'UNLOCKED ' + datec(today(0),'mm/dd/yyyy')  +'  ' + timec(now(0),'hh:mm ') + THISUSER
. open  (LOCK_DBS) append  iostat= FILE_IOSTAT lrecl=200
.   ifthen (FILE_IOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.     write 'Users can sign in: ' STR$1
.   else
.     display infobox 'Unable to remove lock.  DB IS STILL LOCKED'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|>
next message
endif

ifthen (m_id eq USERSTATS )
|< USERSTATS
.   execute dbms "call DCCPROCF.DIALOG.USER_STATS"      |DCC
|>
next message
endif

if (m_id eq 0) exit message

end message


end dialog
|{ Exit
| append log in file
|}
|{ Footer
|
|
subprocedure SHOW_CUR_DBS
<COMMENT> write 'Show already connected DBs'
c list all DBs
. ifthen (system(40) = 0)
.   hide item CUR_DBS
.   hide item CUR_DBS$
. else
.   show item CUR_DBS
.   show item CUR_DBS$
. endif
. for N=1,SYSTEM(40)
.   append item CUR_DBS,dbname(n)
. end for
end subprocedure
|
|
subprocedure GET_DB#  |instead of using gettxt this allows more flexibility and consistency
c Get the DB name and number
<COMMENT> write 'Get the database reference #'
. if (getnitem(DB_NAME)=0) exit subprocedure | NO DBS to cycle through
. for DB# = 1, 100                                |101 means DB not found in list
.   if (gettxt(DB_NAME) = DB$N(DB#)) exit for
. end for
. ifthen (DB# ne 101)
.   set item DB_PATH, DIR$(DB#)
. else
.   set item DB_PATH, 'Incorrect Path'
. endif
. if (gettxt(DB_NAME)='')
end subprocedure
|
|
subprocedure GET_MST#
c Attach Master if needed   MST_NUM=0=no master
<COMMENT> write 'Get the reference # for master'
. compute MST_NUM = 0                                    |Safe side is NO master
. open (MSTLIST) read | / dsnvar = MSTLIST$
.   loop
.     read (MSTLIST,end=done) FILE_LINE$ (A100)              | 1. Cycle through the list of authorized users...
.     ifthen (trimlr(sbst(FILE_LINE$,1,17)) = gettxt(DB_NAME))      | 2. Check the list for DB names that match this DB...
.       MST_IP  = pack(sbst(FILE_LINE$,19,16))
.       if( (MST_IP EQ '') OR (EXISTS(MST_IP) EQ 0) ) MST_IP = '192.168.53.236' | DEFAULT IP
.       MST_NUM = numbr(sbst(FILE_LINE$,36,4))
.     endif
.   end loop
.   done:
. close (MSTLIST)
. if (exists(MST_NUM) = 0) MST_NUM = 0
. ifthen (MST_NUM = 0)
.   set item MST_NUM#, ''
. elseif (MST_NUM gt 1999)
.   set item MST_NUM#, MST_IP + ':' + format(MST_NUM)
. endif
end subprocedure
|
|
|
subprocedure SET_MST#
| play it on the safe side, if a master is connected already disconnect all databases from current SIR session.  Better safe than sorry.
<COMMENT> write 'Connect master. If a master was already attached, disconnect it'
. ifthen (system(38)=1)  |Master is handing the session.  If differnet MST# disconnet all connected DBs to solve master issues
.   if(system(68) ge 1)  execute dbms "COPY DIFFERENCE FILE"  | no one is in, so DFC
.   execute dbms "CALL DCCPROCF.BASE.MSTCLEAR" |Start with no master
.   write 'You are now disconnected from master.'
.   while (system(40) gt 0)
.     DB_NAME$ = pack(DBNAME(0))
.     write 'You were connected to: ' DB_NAME$
.     pql disconnect database DB_NAME$
.   end while
. endif
| Now try to connect Master if applicable
. ifthen (MST_NUM gt 2000)
.   SERVER$ = trim(sglobal('SERVERA'))
.   STR$1 = 'SET MASTER ' + MST_IP + ':' + format(MST_NUM)  | HARD CODED
.   MST_TRIES = 0 | try to connect master three times
.   while (system(38) eq 0)
.     execute dbms STR$1
.     ifthen (system(38) eq 0) MST_TRIES = MST_TRIES +1; wait 5
.     else exit while
.     endif
.     if (MST_TRIES ge 3) exit while | three tries your out.
.   end while
.   wait 10  | necessary before trying DB.  It helps.
. endif
. ifthen (MST_NUM gt 2000)
.   ifthen (system(38) eq 0)
.     open (MST_BAD) append lrecl = 500
.       STR$1 = 'ATC Tried MST on ' + MST_IP +': ' + format(MST_NUM)  +'  '  + datec(today(0),'mm/dd/yyyy') + '  ' + pad(timec(now(0),'hh:mm:ss'),' ',12,12) + THISUSER + ' db:' + DB$N(DB#)
.       write (MST_BAD) STR$1
.     close (MST_BAD)
.   else
.     set item MST_NUM#, gettxt(MST_NUM#) + ' Connected'
.   endif
. endif
end subprocedure SET_MST#
|
|
|
subprocedure DISPLAY_LOCK_LIST
| basic logic.  If a database is lock and then unlocked, the unlocked will always be after the lock.  So basically it flips between locked and unlocked to finally decide the final outcome.
<COMMENT> write 'Display locked DBs.'
. remove all LOCK_LIST
. open (LOCK_DBS) read lrecl=300 iostat =  FILE_IOSTAT
.   ifthen (FILE_IOSTAT eq 0)
.     loop
.       read (LOCK_DBS,end = done) FILE_LINE$ (A300)              | 1. Cycle through locked databases
.       CHECK_DBNAME_LOCK = trimlr(substr(FILE_LINE$, 1, 32))
.       CHECK_DBSTAT_LOCK = trimlr(substr(FILE_LINE$, 35, 8))
.       ifthen (CHECK_DBSTAT_LOCK eq 'LOCKED')
.         for DUMB_NUM# = 1, 32
.           if (LOCKED_DB_ARRAY (DUMB_NUM#) EQ CHECK_DBNAME_LOCK) EXIT FOR
.           ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) eq '0')
.             LOCKED_DB_ARRAY (DUMB_NUM#) = CHECK_DBNAME_LOCK
.             exit for | assigned first available spot for the database name
.           endif
.         end for
.       elseif (CHECK_DBSTAT_LOCK eq 'UNLOCKED')  | do something to mark it as unlocked
.         for DUMB_NUM# = 1,32
.           ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) = CHECK_DBNAME_LOCK )
.             LOCKED_DB_ARRAY (DUMB_NUM#) = '0'
|             note: that there is no "exit for".  I want to cycle through everything so I don't miss one accidentaly.
.           endif
.         end for
.       endif
.     end loop
.     done:
.   else
|.     display infobox 'Cannot open file to lock database' + char(13) + LOCK_DBS
.   endif
. close (LOCK_DBS)
. for DUMB_NUM# = 1,32
.   ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) ne '0')
.     append item LOCK_LIST, LOCKED_DB_ARRAY (DUMB_NUM#)
.   endif
. end for
. ifthen (getnitems(LOCK_LIST) eq 0) hide item LOCK_LIST; hide item LOCK_LAB
. else show item LOCK_LIST; show item LOCK_LAB
. endif
end subprocedure
|
|
subprocedure CHECKPOISON
<COMMENT> write 'Check for POISON Pill'
. ifthen (fileis(dsn('POISON')) eq 1) | NO LOGINS
.   set item LOCK_ALL, 'Enable Log In'
.   show item DBA_NOTE
.   set item DBA_NOTE, "!!!! NO LOG INS  - GENERIC TEXT!!!"
.   STR$1 = "We are currently upgrading our systems."
.   DUMB_NUM# = 0
.   open (POISON) read lrecl = 500
.     loop
.       read (POISON, end=done) FILE_LINE$ (A200)
.       DUMB_NUM# = DUMB_NUM# + 1
.       ifthen(DUMB_NUM# eq 3 or 4)
.         STR$1 = STR$1 + char(13) + char(13) + FILE_LINE$
.       endif
.     end loop
.     done:
.   close (POISON)
.   set item DBA_NOTE, STR$1
. endif
end subprocedure
|
|
subprocedure SETUSER
. ifthen ('<USERA>' eq 'GNEILSx')| or 'HANDREWS' OR 'DMERLE')
.   WHOAREYOU = '<USERA>'
.   display textbox "Who are you?" response resvar, WHOAREYOU
.   if (len(TRIMLR(WHOAREYOU)) GT 0) DUMB_NUM# = globals('USERA',upper(WHOAREYOU))
.   WHOAREYOU = '2'
.   display textbox "Security Level: Pick a number between 300 and 400." response resvar, WHOAREYOU
.   if (len(TRIMLR(WHOAREYOU  )) GT 0) DUMB_NUM# = globals('GSECLEV',WHOAREYOU  )
. endif
end subprocedure

subprocedure CHECKMASTER
<COMMENT> write 'Check Master'
. ifthen (fileis(dsn('MST_BAD')) eq 1) | There is a problem
.   if then (nglobal('GSECLEV') eq 1)  |database admins especially important for other Databases
.     display infobox 'Someone is having a problem with a database connection OR master.  Please check and clear any warnings'
.   endif
. endif
end subprocedure

subprocedure SHOWDBS
<COMMENT> write 'Read the user list. See if user is there'
. remove all DB_NAME
. open (MSTLIST) read
.   loop
.     read (MSTLIST,end = DONE) FILE_LINE$ (A100)
.     ifthen (sbst(FILE_LINE$,1,1) ne '|')
.       DB_NAME$ = trim(sbst(FILE_LINE$,1,18))
.       append item DB_NAME,DB_NAME$
.     endif
.   end loop
.   DONE:
. close (MSTLIST)
end subprocedure SHOWDBS

end program
|}

