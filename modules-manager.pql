PROCEDURE      MODULES.MANAGER:T  (157964,40168)  |Last amended Apr 11, 2015,11:09:28
|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| Creator:   Greg Neils
| Created:   1/01/2007
| Updated:   about every 3 months
| Called by: When a SIR session starts without a DB
| Reason:    Display a list of DBs to connect to.
print back noremarks nocommands user
GCOMPUTE COMMENT = '| '
attribute POISON    filename = '<GDATA4>DCC\ATC\POISON.log'
attribute MST_BAD   filename = '<GDATA4>DCC\ATC\MST_BAD.txt'
attribute MST_FIXED filename = '<GDATA4>DCC\ATC\MST_FIXED.txt'
attribute LOCK_DBS  filename = '<GDATA4>DCC\ATC\LOCKED_DBS.log'
|
|
program crwarn
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 ID_00002                        ; preset ID_00002                         (1 )
integer*1 CUR_DBS$                        ; preset CUR_DBS$                         (2 )
integer*1 DB_PATH                         ; preset DB_PATH                          (3 )
integer*1 MST_NUM#                        ; preset MST_NUM#                         (4 )
integer*1 CUR_DBS                         ; preset CUR_DBS                          (5 )
integer*1 DB_NAME                         ; preset DB_NAME                          (6 )
integer*1 READ_WARN                       ; preset READ_WARN                        (7 )
integer*1 CLEAR_WARN                      ; preset CLEAR_WARN                       (8 )
integer*1 LOCK_DB                         ; preset LOCK_DB                          (9 )
integer*1 LOCK_READ                       ; preset LOCK_READ                        (10 )
integer*1 LOCK_ALL                        ; preset LOCK_ALL                         (11 )
integer*1 LOCK_LIST                       ; preset LOCK_LIST                        (12 )
integer*1 LOCK_LAB                        ; preset LOCK_LAB                         (13 )
integer*1 DBA_NOTE                        ; preset DBA_NOTE                         (14 )
integer*1 USERSTATS                       ; preset USERSTATS                        (15 )
integer*1 SETPROCF                        ; preset SETPROCF                         (16 )
integer*1 CURRENT_PROCNAME                ; preset CURRENT_PROCNAME                 (17 )
integer*1 ID_00003                        ; preset ID_00003                         (18 )
integer*1 ID_00004                        ; preset ID_00004                         (19 )
integer*1 ID_00005                        ; preset ID_00005                         (20 )
integer*1 ID_00006                        ; preset ID_00006                         (21 )
integer*1 ID_00007                        ; preset ID_00007                         (22 )
integer*1 ID_00008                        ; preset ID_00008                         (23 )
integer*1 ID_00009                        ; preset ID_00009                         (24 )
integer*1 NEW_USER_NAME                   ; preset NEW_USER_NAME                    (25 )
integer*1 NEW_SEC_LEVEL                   ; preset NEW_SEC_LEVEL                    (26 )
integer*1 ID_00012                        ; preset ID_00012                         (27 )
integer*1 ID_00013                        ; preset ID_00013                         (28 )
integer*1 SETGUI                          ; preset SETGUI                           (29 )
integer*1 ID_00014                        ; preset ID_00014                         (30 )
integer*1 ID_00015                        ; preset ID_00015                         (31 )
integer*1 ID_00016                        ; preset ID_00016                         (32 )
integer*1 ID_00017                        ; preset ID_00017                         (33 )
integer*1 ID_00018                        ; preset ID_00018                         (34 )
integer*1 B_DB_INFO                       ; preset B_DB_INFO                        (35 )
integer*1 B_MASTER_INFO                   ; preset B_MASTER_INFO                    (36 )
integer*1 B_SYSTEM_INFO                   ; preset B_SYSTEM_INFO                    (37 )
integer*1 B_GLOBAL_INFO                   ; preset B_GLOBAL_INFO                    (38 )
integer*1 ID_00023                        ; preset ID_00023                         (39 )
integer*1 ID_00024                        ; preset ID_00024                         (40 )
integer*1 ID_00025                        ; preset ID_00025                         (41 )
integer*1 ID_00026                        ; preset ID_00026                         (42 )
integer*1 ID_00027                        ; preset ID_00027                         (43 )
integer*1 ID_00028                        ; preset ID_00028                         (44 )
integer*1 ID_00029                        ; preset ID_00029                         (45 )
integer*1 ID_00030                        ; preset ID_00030                         (46 )
integer*1 GLOBAL_NAME                     ; preset GLOBAL_NAME                      (47 )
integer*1 GLOBAL_VALUE                    ; preset GLOBAL_VALUE                     (48 )
integer*1 ATTRIBUTE_NAME                  ; preset ATTRIBUTE_NAME                   (49 )
integer*1 ATTRIBUTE_VALUE                 ; preset ATTRIBUTE_VALUE                  (50 )
integer*1 ID_00036                        ; preset ID_00036                         (51 )
integer*1 ID_00037                        ; preset ID_00037                         (52 )
integer*1 ID_00039                        ; preset ID_00039                         (53 )
integer*1 B_MY_INFO                       ; preset B_MY_INFO                        (54 )
integer*1 ID_00041                        ; preset ID_00041                         (55 )
integer*1 DEFAULT_OUTPUT                  ; preset DEFAULT_OUTPUT                   (56 )
integer*1 ID_00042                        ; preset ID_00042                         (57 )
integer*1 ID_00043                        ; preset ID_00043                         (58 )
integer*1 APP_DIRECTORY                   ; preset APP_DIRECTORY                    (59 )
integer*1 OUTPUT_FILE                     ; preset OUTPUT_FILE                      (60 )
integer*1 ID_00045                        ; preset ID_00045                         (61 )
integer*1 ID_00046                        ; preset ID_00046                         (62 )
integer*1 ID_00047                        ; preset ID_00047                         (63 )
integer*1 MY_USER_NAME                    ; preset MY_USER_NAME                     (64 )
integer*1 ID_00048                        ; preset ID_00048                         (65 )
integer*1 MY_SEC_LEVEL                    ; preset MY_SEC_LEVEL                     (66 )
integer*1 SET_USER_INFO                   ; preset SET_USER_INFO                    (67 )
integer*1 m_page; preset m_page (1)

|{ Prologue
|}

dialog "D.C.C. MANAGER"

|{ Controls
postype 1
line     ID_00002                        ,   0, 344,   0, 581
label    CUR_DBS$                        ,  60,      380,  98, "Already connected to..."
label    DB_PATH                         , 213,      390, 148, "Changes...............sadfasfaffadsf"
label    MST_NUM#                        , 223,      390, 148, "Master#"
list     CUR_DBS                         ,  70,  57, 380,  99, 0
list     DB_NAME                         ,  55, 154, 390,  99, 0
button   READ_WARN                       ,  57,      175,  80, 0, "Edit"
button   CLEAR_WARN                      ,  57,       93,  80, 0, "Clear"
button   LOCK_DB                         , 165,       30,  80, 0, "Lock DBNAME"
button   LOCK_READ                       , 179,       30,  80, 0, "Open Lock File"
button   LOCK_ALL                        , 230,       30,  80, 0, "Lock Everything"
list     LOCK_LIST                       , 102,  57,  30,  99, 0
label    LOCK_LAB                        ,  91,       30, 100, "Double click to unlock."
label    DBA_NOTE                        ,  11,       19, 146, "Poison Pill Active"
button   USERSTATS                       , 320,       20,  80, 0, "User Stats"
choice   SETPROCF                        ,  80,       96,  92
label    CURRENT_PROCNAME                ,  61,       97, 196, "Changes to Procf Name"
label    ID_00003                        ,  80,       20,  74, "Set Proc File"
label    ID_00004                        ,  60,       20,  74, "Current Proc File"
label    ID_00005                        ,  60,       20,  64, "ATC Warnings"
label    ID_00006                        ,  80,       20,  40, "DB Locks"
label    ID_00007                        , 220,       20, 100, "System Wide Locks"
button   ID_00008                        , 320,      180,  80, 0, "Verify All DBs"
label    ID_00009                        , 180,       30,  79, "Change User Name"
edit     NEW_USER_NAME                   , 190,       51,  80, 0, 0
edit     NEW_SEC_LEVEL                   , 190,      140,  21, 0, 0
label    ID_00012                        , 180,      140,  20, "Sec Lev"
label    ID_00013                        ,  60,       20,  74, "Run GUI"
choice   SETGUI                          ,  60,      100,  80
button   ID_00014                        ,  80,      100,  80, 0, "System.AllCall"
label    ID_00015                        ,  80,       20,  74, "Compile"
button   ID_00016                        ,  95,      100,  80, 0, "Screens.AllCall"
button   ID_00017                        , 320,      240,  80, 0, "Restructure DB"
button   ID_00018                        , 320,       80,  80, 0, "Masters Info"
button   B_DB_INFO                       ,   6,      259,  64, 0, "2) Database Info"
button   B_MASTER_INFO                   ,   6,      413,  64, 0, "4) Master Info"
button   B_SYSTEM_INFO                   ,   6,      336,  64, 0, "3) System Info"
button   B_GLOBAL_INFO                   ,   6,      490,  64, 0, "5) Globals / Atts"
label    ID_00023                        ,  22,      414,  73, "Master Info"
label    ID_00024                        ,  22,      337,  61, "System Info"
label    ID_00025                        ,  22,      259,  61, "Database Info"
line     ID_00026                        ,  38,   1,   0, 581
button   ID_00027                        , 320,      100,  80, 0, "Call ATC"
label    ID_00028                        ,  23,      491,  40, "Other Info"
label    ID_00029                        ,  60,       20,  40, "Globals"
label    ID_00030                        ,  60,      300,  48, "Attibutes"
list     GLOBAL_NAME                     ,  75, 250,  30,  80, 0
list     GLOBAL_VALUE                    ,  75, 250, 115, 140, 0
list     ATTRIBUTE_NAME                  ,  75, 248, 320,  80, 0
list     ATTRIBUTE_VALUE                 ,  75, 248, 405, 164, 0
button   ID_00036                        ,  57,       70,  80, 0, "Edit"
button   ID_00037                        ,  57,      350,  80, 0, "Edit"
line     ID_00039                        ,  51, 284, 290,   1
button   B_MY_INFO                       ,   6,      209,  40, 0, "1) My Info"
label    ID_00041                        ,  22,      209,  61, "My Info"
label    DEFAULT_OUTPUT                  , 100,      121, 208, "Default Output"
label    ID_00042                        , 100,       20,  98, "Current Output Folder"
label    ID_00043                        , 290,       21,  64, "App Dirictory"
label    APP_DIRECTORY                   , 290,       86, 184, "APP_DIRECTORY"
label    OUTPUT_FILE                     , 110,      121, 208, "OUTPUT_FILE"
label    ID_00045                        , 110,       20,  98, "Current Output File"
label    ID_00046                        ,  45,      375,  52, "Databases"
label    ID_00047                        , 160,       20,  52, "User Name:"
label    MY_USER_NAME                    , 160,       74,  88, "My User Name"
label    ID_00048                        , 160,      173,  53, "Sec. Level:"
label    MY_SEC_LEVEL                    , 160,      230,  40, "My Sec. Level"
button   SET_USER_INFO                   , 190,      180,  80, 0, "Set"
|}

initial
|{ Attribs
|< CUR_DBS$
. SET ITEM FONT CUR_DBS$,1,0,0, 0,""
|>
|< READ_WARN
. SET ITEM FONT READ_WARN,1,0,0, 0,""
|>
|< CLEAR_WARN
. SET ITEM FONT CLEAR_WARN,1,0,0, 0,""
|>
|< LOCK_DB
. SET ITEM FONT LOCK_DB,1,0,0, 0,""
|>
|< LOCK_READ
. SET ITEM FONT LOCK_READ,1,0,0, 0,""
|>
|< LOCK_ALL
. SET ITEM FONT LOCK_ALL,1,0,0, 0,""
|>
|< DBA_NOTE
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#FF0000/#000000"
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#FF0000/#000000"
|>
|< USERSTATS
. SET ITEM FONT USERSTATS,1,0,0, 0,""
|>
|< ID_00003
. SET ITEM FONT ID_00003,1,0,0, 1,""
|>
|< ID_00004
. SET ITEM FONT ID_00004,1,0,0, 1,""
|>
|< ID_00005
. SET ITEM FONT ID_00005,1,0,0, 1,""
|>
|< ID_00006
. SET ITEM FONT ID_00006,1,0,0, 1,""
|>
|< ID_00007
. SET ITEM FONT ID_00007,1,0,0, 1,""
|>
|< ID_00008
. SET ITEM FONT ID_00008,1,0,0, 0,""
|>
|< ID_00009
. SET ITEM FONT ID_00009,1,0,0, 1,""
|>
|< ID_00012
. SET ITEM FONT ID_00012,1,0,0, 1,""
|>
|< ID_00013
. SET ITEM FONT ID_00013,1,0,0, 1,""
|>
|< ID_00014
. SET ITEM FONT ID_00014,1,0,0, 0,""
|>
|< ID_00015
. SET ITEM FONT ID_00015,1,0,0, 1,""
|>
|< ID_00016
. SET ITEM FONT ID_00016,1,0,0, 0,""
|>
|< ID_00017
. SET ITEM FONT ID_00017,1,0,0, 0,""
|>
|< ID_00018
. SET ITEM FONT ID_00018,1,0,0, 0,""
|>
|< ID_00023
. SET ITEM FONT ID_00023,1,0,0, 1,""
. SET ITEM FONT ID_00023,1,0,0, 1,""
|>
|< ID_00024
. SET ITEM FONT ID_00024,1,0,0, 1,""
. SET ITEM FONT ID_00024,1,0,0, 1,""
|>
|< ID_00025
. SET ITEM FONT ID_00025,1,0,0, 1,""
. SET ITEM FONT ID_00025,1,0,0, 1,""
|>
|< ID_00027
. SET ITEM FONT ID_00027,1,0,0, 0,""
|>
|< ID_00028
. SET ITEM FONT ID_00028,1,0,0, 0,""
|>
|< ID_00029
. SET ITEM FONT ID_00029,1,0,0, 1,""
|>
|< ID_00030
. SET ITEM FONT ID_00030,1,0,0, 1,""
|>
|< ID_00041
. SET ITEM FONT ID_00041,1,0,0, 1,""
. SET ITEM FONT ID_00041,1,0,0, 1,""
|>
|< ID_00042
. SET ITEM FONT ID_00042,1,0,0, 1,""
|>
|< ID_00043
. SET ITEM FONT ID_00043,1,0,0, 1,""
|>
|< ID_00045
. SET ITEM FONT ID_00045,1,0,0, 1,""
|>
|< ID_00046
. SET ITEM FONT ID_00046,1,0,0, 1,""
|>
|< ID_00047
. SET ITEM FONT ID_00047,1,0,0, 1,""
|>
|< MY_USER_NAME
. SET ITEM FONT MY_USER_NAME,1,0,0, 1,""
|>
|< ID_00048
. SET ITEM FONT ID_00048,1,0,0, 1,""
|>
|< MY_SEC_LEVEL
. SET ITEM FONT MY_SEC_LEVEL,1,0,0, 1,""
|>
|< SET_USER_INFO
. SET ITEM FONT SET_USER_INFO,1,0,0, 0,""
|>

|}
|{ Init
string  *  256    STR$1  STR$2                       | helpful to construct strings for execution and messages
integer *    1    DB#                                | ARRAY # corresponding to the DB
string  *   32    MST_IP                             | Master IP address.  Databases can get a specific master IP.
integer *    4    MST_NUM                            | MST_NUM if from the file
integer *    4    CONNSTAT                           | Did the database connect
integer *    1    YESNOVAR                           | Run Sign in first yes no answer
string  *  200    FILE_LINE$                          | lines in the
string  *   10    EXT                                | file extension for a sysproc subroutine
string  *   32    THISUSER                           | USER_NAME
string  *   50    DB_NAME$                           | Name of database
string  *  300    DBPATH SIRPATH CHKPATH             | To find out if it is a DB in the Counting DB.
integer *    2    DUMB_NUM#                          | Use whenever you want to.
integer *    1    ADD_MST                            | Do they need to connect to master
string  *   32    array LOCKED_DB_ARRAY (32)         | Which DBs are locked.
string  *   32    CHECK_DBNAME_LOCK SERVER$          | Name in the text file of the locked or unlocked DB
string  *    8    CHECK_DBSTAT_LOCK                  | Status: LOCKED   or   UNLOCKED
integer *    1    DB_IS_LOCKED                       | 1 = LOCKED... ONLY ADMINS.    0= NOT LOCKED, EVERYONE.
integer *    1    RC                                 | Return code.  -1=cancel; 0 =OK
integer *    1    MST_TRIES                          | How many times to try connecting to master
string  *   32    WHOAREYOU  | ALLOWS US TO CHANGE GLOBAL USERA VALUE
integer *    4    RESVAR
string  *   32    CALLGUI                            | Which GUI to call.
integer *    1    VIEW_MYINFO VIEW_DB VIEW_SYSTEM VIEW_MASTER VIEW_GLOBALS_ATTS
SET VIEW_MYINFO(1) VIEW_DB (2) VIEW_SYSTEM (3) VIEW_MASTER (4) VIEW_GLOBALS_ATTS (5)
value labels CONNSTAT
  (-2000) ' Bad select value in Host routine'
  (-2001) ' Specified name for database does not match'
  (-2002) ' Invalid password for database'
  (-2003) ' Password needed to attach database'
  (-2004) ' No CIRs/records found within specified restrictions'
  (-2005) ' No more CIRs/records within specified restrictions'
  (-2006) ' Maximum record count exceeded for current CIR'
  (-2008) ' Data file empty'
  (-2009) ' Invalid date string'
  (-2010) ' Invalid time string'
  (-2011) ' No. of days outside valid date range'
  (-2012) ' Data file is full'
  (-2013) ' In use flag set - run VERIFY utility'
  (-2027) ' Data file is empty after last delete'
  (-2028) ' Retrieval update mode required to add new CIR/record'
  (-2029) ' Specified record type locked or undefined'
  (-2030) ' Maximum case limit exceeded - restructure'
  (-2031) ' Data file master index overflow - restructure'
  (-2032) ' Attempted to position beyond end of data file'
  (-2033) ' Database previously opened but not closed'
  (-2034) ' Retrieval update mode required to delete case/record'
  (-2040) ' Cannot open Journal file'
  (-2041) ' Database not initialized'
  (-2042) ' Database closed - must reopen'
  (-2043) ' Invalid Database Reference'
  (-2044) ' Cannot locate update level on reload file'
  (-2045) ' Cannot close database currently used by some stream'
  (-2046) ' Cannot open reload input file'
  (-2047) ' Invalid HOST password specified to use database'
  (-2048) ' Must be DBA to Modify Schema'
  (-2049) ' Invalid lock flag specified'
  (-2053) ' Database already exists'
  (-2054) ' Update level overflow - unload and reload the database'
  (-2055) ' In use by other process'
  (-2056) ' Not found on specified disk'
  (-2057) ' Access forbidden'
  (-2058) ' Problem with open routine'
|
set DB#        (0)
set LOCKED_DB_ARRAY * ('0')     | No locks.  It is replaced by DBName if locked
set DB_IS_LOCKED      (0)
|
set item font DB_NAME      ,1,0,0,6,'ARIAL'|BOLD,ITALIC,UNDERL,SIZE,FONT
hide item DBA_NOTE
THISUSER  = '<USERA>'
STR$1 = SIRUSER(THISUSER)
C PROCFILES
APPEND ITEM SETPROCF, 'DCCPROCF'
APPEND ITEM SETPROCF, 'SIR014'
APPEND ITEM SETPROCF, 'GUIPROCF'
APPEND ITEM SETPROCF, 'GUIPROCF-RC'
c GUIS
APPEND ITEM SETGUI, 'Custom'
APPEND ITEM SETGUI, 'Nav Original'
APPEND ITEM SETGUI, 'Nav 2'
APPEND ITEM SETGUI, 'New GUI'
APPEND ITEM SETGUI, 'New GUI-RC'
|
<COMMENT> write 'including DB List'
include file DBSLIST
|
execute subprocedure CHECKMASTER
execute subprocedure CHECKPOISON
execute subprocedure SHOW_PROCFILE
execute subprocedure SHOWDBS
|
set item LOCK_DB, "Lock " + gettxt(DB_NAME)
execute subprocedure GET_DB#
execute subprocedure GET_MST#
execute subprocedure SHOW_CUR_DBS
execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|
|
focus item DB_NAME
|
execute subprocedure BEFORE_PAGE | load the initial information for the initial page
|}
execute subprocedure page
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq DB_NAME )
|< DB_NAME
c connects to master and DB and either exits or stay put depending on connection.
. set item LOCK_DB, "Lock " + gettxt(DB_NAME)
. ifthen (nglobal('GSECLEV') ne 1)  | DBAs should never ever be locked out.
.   ifthen (DB_IS_LOCKED eq 1)
.     display infobox 'The database is being updated.  Try back in a few minutes.'
.     NEXT MESSAGE
.   endif
. endif
. execute subprocedure GET_DB#
. execute subprocedure GET_MST#
|>
next message
endif

ifthen (m_id eq READ_WARN )
|< READ_WARN
compute STR$1 = 'EDITFILE "' + dsn('MST_BAD')+'"/clear'; EXECUTE DBMS STR$1
|>
next message
endif

ifthen (m_id eq CLEAR_WARN )
|< CLEAR_WARN
ifthen (fileis(dsn('MST_BAD')) ne 1)
. display infobox "Sorry the file was not found"
. next message
endif
. open (MST_BAD) read  lrecl = 500
.   open (MST_FIXED) append lrecl = 500
.     loop
.       read (MST_BAD, end=done) FILE_LINE$ (A200)
.       write (MST_FIXED) FILE_LINE$ (A200)
.     end loop
.     done:
.   close (MST_FIXED)
. close (MST_BAD)

. YESNOVAR = DELFILE (dsn('MST_BAD'))
. ifNOTthen (YESNOVAR eq 0)
.   display infobox "There was an error deleting the file.  Please delete the file by hand"
.   display infobox ["path is:" + dsn('MST_BAD')]
. endif
|>
next message
endif

ifthen (m_id eq LOCK_DB )
|< LOCK_DB
| check master for users, lock database so no more users can get in.
. for DUMB_NUM#=1,getnitem(LOCK_LIST)
.   ifthen (getitxt(LOCK_LIST,DUMB_NUM#) eq gettxt(DB_NAME))
.     display infobox "Look, it is already Locked."
.     next message
.   endif
. end for
. execute subprocedure GET_MST#
. execute subprocedure SET_MST#
. ifthen ( system(69) gt 0)
.   STR$1 = 'Master ' + MST_IP +':' + format(MST_NUM) + ' is attached to ' + format(system(69)) + ' DBs: ' + char(13)
.   for DUMB_NUM# = 1, system(69)
.     STR$1 = STR$1 + char(13)+ getmdbn(DUMB_NUM#)
.   end for
.   display infobox STR$1
. endif
. ifthen (system(68) gt 1)
.   STR$1 = 'Master ' + MST_IP + ':' + format(MST_NUM) + ' has ' + format(system(68)) + ' Clients' + char(13)
.   for DUMB_NUM# = 1, system(68)
.     STR$1 = STR$1 + char(13) + getmcadd(getmclid(DUMB_NUM#))
.     if (getmclst(DUMB_NUM#) ne 0) STR$1 = STR$1 +  '  at  ' + timec(getmclst(DUMB_NUM#), 'hh:mm:ss')
.   end for
.   display infobox STR$1
. endif

. execute dbms "CALL DCCPROCF.BASE.MSTCLEAR"


. STR$1= pad(gettxt(DB_NAME),' ',34,34) + 'LOCKED   ' + datec(today(0),'mm/dd/yyyy')  +'  ' + timec(now(0),'hh:mm ') + THISUSER

. display textbox "Reason?" response YESNOVAR, STR$2
. if (YESNOVAR eq -1) next message | canceled
. if (exists(STR$2) eq 1) STR$1 = STR$1 + '  Reason ' + STR$2
. open  (LOCK_DBS) append iostat= FILE_IOSTAT lrecl=300
.   ifthen (FILE_IOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.   else
.     display infobox 'Error locking database.  DB IS NOT LOCKED.'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST
|>
next message
endif

ifthen (m_id eq LOCK_READ )
|< LOCK_READ
. STR$1 ="EDITFILE '" + dsn('LOCK_DBS') + "'"
. execute dbms STR$1
|>
next message
endif

ifthen (m_id eq LOCK_ALL )
|< LOCK_ALL
. ifthen (fileis(dsn('POISON')) eq 0)
.   display yncbox "Stop everyone from signing in?" response YESNOVAR
.   if (YESNOVAR ne 1) next message  | do not continue
.   STR$1 =  'We expect to be back on-line in 1 hour,'
.   display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   while (exists(STR$1) eq 0)
.     display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   end while
.   set item LOCK_ALL, "Log in Disabled"
.   open (POISON) write
.     write (POISON) 'Nobody can sign in until this file is deleted'
.     write (POISON) 'Created by ' THISUSER | <USERA> ' [upper(getenv('USER_NAME'))]
.     write (POISON) 'Started ' [datec(today(0),'Www. mm/dd/yyyy') ] '  at  '[timec(now(0),'hh:mm pp') ]
.     write (POISON) STR$1
.   close (POISON)
.   show item DBA_NOTE
.   set item DBA_NOTE, "!!!!   NO LOG INS   !!!!!!"

.   display infobox "All access through the ATC have been disabled.  Nobody can sign in."+char(13)+char(13)
                   +"If a user is in a database, they may stay in, but once out, they may not log back in."
. else
.   display yncbox "Allow everyone to sign in through the ATC?" response YESNOVAR
.   ifthen (YESNOVAR eq 1)
.     YESNOVAR = DELFILE (dsn('POISON'))
.     ifthen (YESNOVAR eq 0)
.       display infobox "Everyone may now sign in."
.       set item LOCK_ALL, "Log in Enabled."
.       set item DBA_NOTE, ""
.     else
.       display infobox "There was an error deleting the file. It still exists. No sign ins allowed"
.       display infobox ["path is:" + dsn('POISON')]
.       set item LOCK_ALL, "Log in Disabled."
.       set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.     endif
.   else
.     display infobox "Users are not allowed in."
.     set item LOCK_ALL, "Log in Disabled."
.     set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.   endif
. endif
|>
next message
endif

ifthen (m_id eq LOCK_LIST )
|< LOCK_LIST
. if(M_ARG2 ne 1) NEXT MESSAGE
. STR$1 = pad(gettxt(LOCK_LIST),' ',34,34) + 'UNLOCKED ' + datec(today(0),'mm/dd/yyyy')  +'  ' + timec(now(0),'hh:mm ') + THISUSER
. open  (LOCK_DBS) append  iostat= FILE_IOSTAT lrecl=200
.   ifthen (FILE_IOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.     write 'Users can sign in: ' STR$1
.   else
.     display infobox 'Unable to remove lock.  DB IS STILL LOCKED'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|>
next message
endif

ifthen (m_id eq USERSTATS )
|< USERSTATS
.   execute dbms "call DCCPROCF.DIALOG.USER_STATS"
|>
next message
endif

ifthen (m_id eq SETPROCF )
|< SETPROCF
. ifthen (gettxt(SETPROCF) eq 'GUIPROCF')
. elseif (gettxt(SETPROCF) eq 'GUIPROCF-RC')
. endif
. ifthen (fileis(dsn(gettxt(SETPROCF))) eq 1)
.   execute dbms "set procfile " + gettxt(SETPROCF)
. else
.   display infobox 'Sorry, ' + gettxt(SETPROCF) + ' was not found'
. endif
. execute subprocedure SHOW_PROCFILE
|>
next message
endif

ifthen (m_id eq SETGUI )
|< SETGUI
. execute subprocedure CALLGUI
|>
next message
endif

ifthen (m_id eq ID_00014 )
|< ID_00014
. if(SYSTEM(39) eq 0) display infobox "First connect a DB" ; next message
|>
next message
endif

ifthen (m_id eq ID_00016 )
|< ID_00016
. if(SYSTEM(39) eq 0) display infobox "First connect a DB" ; next message
|>
next message
endif

ifthen (m_id eq ID_00017 )
|< ID_00017
. if(SYSTEM(39) eq 0) display infobox "First connect a DB" ; next message
|>
next message
endif

ifthen (m_id eq B_DB_INFO )
|< B_DB_INFO
. M_PAGE = VIEW_DB
. execute subprocedure BEFORE_PAGE
. execute subprocedure PAGE
|>
next message
endif

ifthen (m_id eq B_MASTER_INFO )
|< B_MASTER_INFO
. M_PAGE = VIEW_MASTER
. execute subprocedure BEFORE_PAGE
. execute subprocedure PAGE
|>
next message
endif

ifthen (m_id eq B_SYSTEM_INFO )
|< B_SYSTEM_INFO
. M_PAGE = VIEW_SYSTEM
. execute subprocedure BEFORE_PAGE
. execute subprocedure PAGE
|>
next message
endif

ifthen (m_id eq B_GLOBAL_INFO )
|< B_GLOBAL_INFO
. M_PAGE = VIEW_GLOBALS_ATTS
. execute subprocedure BEFORE_PAGE
. execute subprocedure PAGE
|>
next message
endif

ifthen (m_id eq ID_00027 )
|< ID_00027
execute dbms "call dccprocf.dialog.atc"
|>
next message
endif

ifthen (m_id eq GLOBAL_NAME )
|< GLOBAL_NAME
select item GLOBAL_VALUE, getpos(GLOBAL_NAME)
|>
next message
endif

ifthen (m_id eq GLOBAL_VALUE )
|< GLOBAL_VALUE
select item GLOBAL_NAME, getpos(GLOBAL_VALUE)
|>
next message
endif

ifthen (m_id eq ATTRIBUTE_NAME )
|< ATTRIBUTE_NAME
select item ATTRIBUTE_VALUE, getpos(ATTRIBUTE_NAME)
|>
next message
endif

ifthen (m_id eq ATTRIBUTE_VALUE )
|< ATTRIBUTE_VALUE
select item ATTRIBUTE_NAME, getpos(ATTRIBUTE_VALUE)
|>
next message
endif

ifthen (m_id eq B_MY_INFO )
|< B_MY_INFO
. M_PAGE = VIEW_MYINFO
. execute subprocedure BEFORE_PAGE
. execute subprocedure PAGE
|>
next message
endif

ifthen (m_id eq SET_USER_INFO )
|< SET_USER_INFO
DUMB_NUM# = globals( 'USERA', gettxt(NEW_USER_NAME))
DUMB_NUM# = globaln( 'GSECLEV', getint(NEW_SEC_LEVEL))
EXECUTE SUBPROCEDURE VIEW_MYINFO
|>
next message
endif

if (m_id eq 0) exit message

end message


end dialog
|{ Exit
| append log in file
|}
|{ Pages
subprocedure page
.  hide item CUR_DBS$
.  hide item DB_PATH
.  hide item MST_NUM#
.  hide item CUR_DBS
.  hide item DB_NAME
.  hide item READ_WARN
.  hide item CLEAR_WARN
.  hide item LOCK_DB
.  hide item LOCK_READ
.  hide item LOCK_ALL
.  hide item LOCK_LIST
.  hide item LOCK_LAB
.  hide item USERSTATS
.  hide item SETPROCF
.  hide item CURRENT_PROCNAME
.  hide item ID_00003
.  hide item ID_00004
.  hide item ID_00005
.  hide item ID_00006
.  hide item ID_00007
.  hide item ID_00008
.  hide item ID_00009
.  hide item NEW_USER_NAME
.  hide item NEW_SEC_LEVEL
.  hide item ID_00012
.  hide item ID_00013
.  hide item SETGUI
.  hide item ID_00014
.  hide item ID_00015
.  hide item ID_00016
.  hide item ID_00017
.  hide item ID_00018
.  hide item ID_00023
.  hide item ID_00024
.  hide item ID_00025
.  hide item ID_00027
.  hide item ID_00028
.  hide item ID_00029
.  hide item ID_00030
.  hide item GLOBAL_NAME
.  hide item GLOBAL_VALUE
.  hide item ATTRIBUTE_NAME
.  hide item ATTRIBUTE_VALUE
.  hide item ID_00036
.  hide item ID_00037
.  hide item ID_00039
.  hide item ID_00041
.  hide item DEFAULT_OUTPUT
.  hide item ID_00042
.  hide item ID_00043
.  hide item APP_DIRECTORY
.  hide item OUTPUT_FILE
.  hide item ID_00045
.  hide item ID_00046
.  hide item ID_00047
.  hide item MY_USER_NAME
.  hide item ID_00048
.  hide item MY_SEC_LEVEL
.  hide item SET_USER_INFO
.  ifthen (m_page EQ 1  )
.    show item CUR_DBS$
.    show item CUR_DBS
.    show item SETPROCF
.    show item CURRENT_PROCNAME
.    show item ID_00003
.    show item ID_00004
.    show item ID_00009
.    show item NEW_USER_NAME
.    show item NEW_SEC_LEVEL
.    show item ID_00012
.    show item ID_00041
.    show item DEFAULT_OUTPUT
.    show item ID_00042
.    show item OUTPUT_FILE
.    show item ID_00045
.    show item ID_00047
.    show item MY_USER_NAME
.    show item ID_00048
.    show item MY_SEC_LEVEL
.    show item SET_USER_INFO
.  endif
.  ifthen (m_page EQ 2  )
.    show item ID_00013
.    show item SETGUI
.    show item ID_00014
.    show item ID_00015
.    show item ID_00016
.    show item ID_00017
.    show item ID_00025
.  endif
.  ifthen (m_page EQ 3  )
.    show item DB_PATH
.    show item MST_NUM#
.    show item DB_NAME
.    show item READ_WARN
.    show item CLEAR_WARN
.    show item LOCK_DB
.    show item LOCK_READ
.    show item LOCK_ALL
.    show item LOCK_LIST
.    show item LOCK_LAB
.    show item USERSTATS
.    show item ID_00005
.    show item ID_00006
.    show item ID_00007
.    show item ID_00008
.    show item ID_00024
.    show item ID_00027
.    show item ID_00043
.    show item APP_DIRECTORY
.    show item ID_00046
.  endif
.  ifthen (m_page EQ 4  )
.    show item ID_00018
.    show item ID_00023
.  endif
.  ifthen (m_page EQ 5  )
.    show item ID_00028
.    show item ID_00029
.    show item ID_00030
.    show item GLOBAL_NAME
.    show item GLOBAL_VALUE
.    show item ATTRIBUTE_NAME
.    show item ATTRIBUTE_VALUE
.    show item ID_00036
.    show item ID_00037
.    show item ID_00039
.  endif
end subprocedure
|}

|{ Footer
|
|
subprocedure SHOW_CUR_DBS
<COMMENT> write 'Show already connected DBs'
c list all DBs
. ifthen (system(40) = 0)
.   hide item CUR_DBS
.   hide item CUR_DBS$
. else
.   show item CUR_DBS
.   show item CUR_DBS$
. endif
. for N=1,SYSTEM(40)
.   append item CUR_DBS,dbname(n)
. end for
end subprocedure
|
|
subprocedure GET_DB#  |instead of using gettxt this allows more flexibility and consistency
c Get the DB name and number
<COMMENT> write 'Get the database reference #'
. if (getnitem(DB_NAME)=0) exit subprocedure | NO DBS to cycle through
. for DB# = 1, 100                                |101 means DB not found in list
.   if (gettxt(DB_NAME) = DB$N(DB#)) exit for
. end for
. ifthen (DB# ne 101)
.   set item DB_PATH, DIR$(DB#)
. else
.   set item DB_PATH, 'Incorrect Path'
. endif
. if (gettxt(DB_NAME)='')
end subprocedure
|
|
subprocedure GET_MST#
c Attach Master if needed   MST_NUM=0=no master
<COMMENT> write 'Get the reference # for master'
. compute MST_NUM = 0                                    |Safe side is NO master
. open (MSTLIST) read | / dsnvar = MSTLIST$
.   loop
.     read (MSTLIST,end=done) FILE_LINE$ (A100)              | 1. Cycle through the list of authorized users...
.     ifthen (trimlr(sbst(FILE_LINE$,1,17)) = gettxt(DB_NAME))      | 2. Check the list for DB names that match this DB...
.       MST_IP  = pack(sbst(FILE_LINE$,19,16))
.       if( (MST_IP EQ '') OR (EXISTS(MST_IP) EQ 0) ) MST_IP = '192.168.53.236' | DEFAULT IP
.       MST_NUM = numbr(sbst(FILE_LINE$,36,4))
.     endif
.   end loop
.   done:
. close (MSTLIST)
. if (exists(MST_NUM) = 0) MST_NUM = 0
. ifthen (MST_NUM = 0)
.   set item MST_NUM#, ''
. elseif (MST_NUM gt 1999)
.   set item MST_NUM#, MST_IP + ':' + format(MST_NUM)
. endif
end subprocedure
|
|
|
subprocedure SET_MST#
| play it on the safe side, if a master is connected already disconnect all databases from current SIR session.  Better safe than sorry.
<COMMENT> write 'Connect master. If a master was already attached, disconnect it'
. ifthen (system(38)=1)  |Master is handing the session.  If differnet MST# disconnet all connected DBs to solve master issues
.   if(system(68) ge 1)  execute dbms "COPY DIFFERENCE FILE"  | no one is in, so DFC
.   execute dbms "CALL DCCPROCF.BASE.MSTCLEAR" |Start with no master
.   write 'You are now disconnected from master.'
.   while (system(40) gt 0)
.     DB_NAME$ = pack(DBNAME(0))
.     write 'You were connected to: ' DB_NAME$
.     pql disconnect database DB_NAME$
.   end while
. endif
| Now try to connect Master if applicable
. ifthen (MST_NUM gt 2000)
.   SERVER$ = trim(sglobal('SERVERA'))
.   STR$1 = 'SET MASTER ' + MST_IP + ':' + format(MST_NUM)  | HARD CODED
.   MST_TRIES = 0 | try to connect master three times
.   while (system(38) eq 0)
.     execute dbms STR$1
.     ifthen (system(38) eq 0) MST_TRIES = MST_TRIES +1; wait 5
.     else exit while
.     endif
.     if (MST_TRIES ge 3) exit while | three tries your out.
.   end while
.   wait 10  | necessary before trying DB.  It helps.
. endif
. ifthen (MST_NUM gt 2000)
.   ifthen (system(38) eq 0)
.     open (MST_BAD) append lrecl = 500
.       STR$1 = 'ATC Tried MST on ' + MST_IP +': ' + format(MST_NUM)  +'  '  + datec(today(0),'mm/dd/yyyy') + '  ' + pad(timec(now(0),'hh:mm:ss'),' ',12,12) + THISUSER + ' db:' + DB$N(DB#)
.       write (MST_BAD) STR$1
.     close (MST_BAD)
.   else
.     set item MST_NUM#, gettxt(MST_NUM#) + ' Connected'
.   endif
. endif
end subprocedure SET_MST#
|
|
|
subprocedure DISPLAY_LOCK_LIST
| basic logic.  If a database is lock and then unlocked, the unlocked will always be after the lock.  So basically it flips between locked and unlocked to finally decide the final outcome.
<COMMENT> write 'Display locked DBs.'
. remove all LOCK_LIST
. open (LOCK_DBS) read lrecl=300 iostat =  FILE_IOSTAT
.   ifthen (FILE_IOSTAT eq 0)
.     loop
.       read (LOCK_DBS,end = done) FILE_LINE$ (A300)              | 1. Cycle through locked databases
.       CHECK_DBNAME_LOCK = trimlr(substr(FILE_LINE$, 1, 32))
.       CHECK_DBSTAT_LOCK = trimlr(substr(FILE_LINE$, 35, 8))
.       ifthen (CHECK_DBSTAT_LOCK eq 'LOCKED')
.         for DUMB_NUM# = 1, 32
.           if (LOCKED_DB_ARRAY (DUMB_NUM#) EQ CHECK_DBNAME_LOCK) EXIT FOR
.           ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) eq '0')
.             LOCKED_DB_ARRAY (DUMB_NUM#) = CHECK_DBNAME_LOCK
.             exit for | assigned first available spot for the database name
.           endif
.         end for
.       elseif (CHECK_DBSTAT_LOCK eq 'UNLOCKED')  | do something to mark it as unlocked
.         for DUMB_NUM# = 1,32
.           ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) = CHECK_DBNAME_LOCK )
.             LOCKED_DB_ARRAY (DUMB_NUM#) = '0'
|             note: that there is no "exit for".  I want to cycle through everything so I don't miss one accidentaly.
.           endif
.         end for
.       endif
.     end loop
.     done:
.   else
|.     display infobox 'Cannot open file to lock database' + char(13) + LOCK_DBS
.   endif
. close (LOCK_DBS)
. for DUMB_NUM# = 1,32
.   ifthen (LOCKED_DB_ARRAY (DUMB_NUM#) ne '0')
.     append item LOCK_LIST, LOCKED_DB_ARRAY (DUMB_NUM#)
.   endif
. end for
. ifthen (getnitems(LOCK_LIST) eq 0) hide item LOCK_LIST; hide item LOCK_LAB
. else show item LOCK_LIST; show item LOCK_LAB
. endif
end subprocedure
|
|
subprocedure CHECKPOISON
<COMMENT> write 'Check for POISON Pill'
. ifthen (fileis(dsn('POISON')) eq 1) | NO LOGINS
.   set item LOCK_ALL, 'Enable Log In'
.   show item DBA_NOTE
.   set item DBA_NOTE, "!!!! NO LOG INS  - GENERIC TEXT!!!"
.   STR$1 = "We are currently upgrading our systems."
.   DUMB_NUM# = 0
.   open (POISON) read lrecl = 500
.     loop
.       read (POISON, end=done) FILE_LINE$ (A200)
.       DUMB_NUM# = DUMB_NUM# + 1
.       ifthen(DUMB_NUM# eq 3 or 4)
.         STR$1 = STR$1 + char(13) + char(13) + FILE_LINE$
.       endif
.     end loop
.     done:
.   close (POISON)
.   set item DBA_NOTE, STR$1
. endif
end subprocedure
|
|
subprocedure SETUSER
. ifthen ('<USERA>' eq 'GNEILSx')| or 'HANDREWS' OR 'DMERLE')
.   WHOAREYOU = '<USERA>'
.   display textbox "Who are you?" response resvar, WHOAREYOU
.   if (len(TRIMLR(WHOAREYOU)) GT 0) DUMB_NUM# = globals('USERA',upper(WHOAREYOU))
.   WHOAREYOU = '2'
.   display textbox "Security Level: Pick a number between 300 and 400." response resvar, WHOAREYOU
.   if (len(TRIMLR(WHOAREYOU  )) GT 0) DUMB_NUM# = globals('GSECLEV',WHOAREYOU  )
. endif
end subprocedure
subprocedure CHECKMASTER
<COMMENT> write 'Check Master'
. ifthen (fileis(dsn('MST_BAD')) eq 1) | There is a problem
.   if then (nglobal('GSECLEV') eq 1)  |database admins especially important for other Databases
.     display infobox 'Someone is having a problem with a database connection OR master.  Please check and clear any warnings'
.   endif
. endif
end subprocedure
subprocedure SHOWDBS
<COMMENT> write 'Read the user list. See if user is there'
. remove all DB_NAME
. open (MSTLIST) read
.   loop
.     read (MSTLIST,end = DONE) FILE_LINE$ (A100)
.     ifthen (sbst(FILE_LINE$,1,1) ne '|')
.       DB_NAME$ = trim(sbst(FILE_LINE$,1,18))
.       append item DB_NAME,DB_NAME$
.     endif
.   end loop
.   DONE:
. close (MSTLIST)
end subprocedure SHOWDBS
subprocedure SHOW_PROCFILE
. set item CURRENT_PROCNAME, PROCNAME(0)
end subprocedure
|
subprocedure CALLGUI
. if(SYSTEM(39) eq 0) display infobox "First connect a DB" ; exit subprocedure
. ifthen(gettxt(SETGUI) EQ 'Custom') CALLGUI = 'SIR014.NAVIGATE.MAIN'
. elseif(gettxt(SETGUI) EQ 'Nav Original') CALLGUI = 'DCCPROCF.NAVIGATE.MAIN'
. elseif(gettxt(SETGUI) EQ 'Nav 2') CALLGUI = 'DCCPROCF.NAVIGATE2.MAIN'
. elseif(gettxt(SETGUI) EQ 'New GUI')
.   CALLGUI = 'GUIPROCF.GUI_MAIN.START'
. elseif(gettxt(SETGUI) EQ 'New GUI-RC')
.   CALLGUI = 'GUIPROCF.GUI_MAIN.START'
. else display infobox 'OOPS NO GUI FOUND'
. endif
. EXECUTE DBMS "CALL " + CALLGUI
end subprocedure
|
subprocedure BEFORE_PAGE
. execute subprocedure BUTTON_BOLD
. ifthen (M_PAGE EQ VIEW_MYINFO)
.   execute subprocedure VIEW_MYINFO
. elseif (M_PAGE EQ VIEW_DB)
.   C DO SOMETHING
. elseif (M_PAGE EQ VIEW_SYSTEM)
.   execute subprocedure VIEW_SYSTEM
. elseif (M_PAGE EQ VIEW_MASTER)
.   C DO SOMETHING
. elseif (M_PAGE EQ VIEW_GLOBALS_ATTS)
.   execute subprocedure VIEW_GLOBALS_ATTS
. else
.   DISPLAY INFOBOX "NO BEFORE PAGE FOR THAT PAGE, PLEASE ADD IT"
. endif
end subprocedure BEFORE_PAGE
|
subprocedure VIEW_MYINFO
. set item DEFAULT_OUTPUT, curdir(0) |+ ':' + dsn(curdir(0))
. set item OUTPUT_FILE, OUTFNAME(0)
. set item MY_USER_NAME, SGLOBAL('USERA')
. set item MY_SEC_LEVEL, SGLOBAL('GSECLEV')
end subprocedure VIEW_MYINFO
|
subprocedure VIEW_SYSTEM
. set item APP_DIRECTORY, appdir(0)
end subprocedure VIEW_SYSTEM
|
subprocedure VIEW_GLOBALS_ATTS
. execute subprocedure LIST_ATTRIBUTES
. execute subprocedure LIST_GLOBALS
end subprocedure
|
subprocedure LIST_ATTRIBUTES
. for FOR_ATTS# = 1, SYSTEM(52)
c   attribute
.   append item ATTRIBUTE_NAME, attrname(FOR_ATTS#)
c   path/VALUE
.   append item ATTRIBUTE_VALUE, dsn(attrname(FOR_ATTS#))
. end for
end subprocedure
|
subprocedure LIST_GLOBALS
for NUM_GLOBALS# = 1, SYSTEM(53)
c   Global
.   append item GLOBAL_NAME, globname(NUM_globals#)
c   Value
.   append item GLOBAL_VALUE, sglobal (globname(NUM_globals#))
end for
end subprocedure
|
subprocedure BUTTON_BOLD
. SET ITEM FONT B_MY_INFO , 0,0,0,0,""
. SET ITEM FONT B_DB_INFO , 0,0,0,0,""
. SET ITEM FONT B_MASTER_INFO, 0,0,0,0,""
. SET ITEM FONT B_SYSTEM_INFO, 0,0,0,0,""
. SET ITEM FONT B_GLOBAL_INFO, 0,0,0,0,""
. ifthen (getfocus(0) = B_MY_INFO) SET ITEM FONT B_MY_INFO , 1,1,0,0,""; WRITE 'SET'
. elseif (getfocus(0) = B_DB_INFO) SET ITEM FONT B_DB_INFO , 1,1,0,0,""
. elseif (getfocus(0) = B_MASTER_INFO) SET ITEM FONT B_MASTER_INFO, 1,1,0,0,""
. elseif (getfocus(0) = B_SYSTEM_INFO) SET ITEM FONT B_SYSTEM_INFO, 1,1,0,0,""
. elseif (getfocus(0) = B_GLOBAL_INFO) SET ITEM FONT B_GLOBAL_INFO, 1,1,0,0,""
. endif
end subprocedure
end program
|}
END PROCEDURE
