PROCEDURE      SCREENS.MAKE_ONE_SCREEN:T  (158331,57800)  |Last amended Apr 12, 2016,16:03:20
C MAKE ONE DATA ENTRY SCREEN THAT WORKS WITH THE MAIN DATA ENTRY GUI
C PASS THE SCREEN NUMBER YOU WANT TO MAKE

. SUBROUTINE SCREENS.MAKE_ONE_SCREEN ( REC_TYPE_NUM ) CRWARN   REPLACE NODATABASE
. INTEGER *      2   REC_TYPE_NUM    | RECORD_TYPE NUMBER
. STRING  *    256   MEMBER_NAME
. string  *    256   RECORD_NAME
. INTEGER *      2   SCREEN_PAGE     | SCREEN PAGE
. INTEGER *      1   SCREEN_LINE     | LINE ON THE SCREEN
. STRING  *    256   MEMBER_LINE     | LINE TO WRITE TO THE MEMBER
. string  *     36   CASE_NAME       | Variable name of case, varname(0, 1)
. integer *      1   CASE_TYPE       | What variable type is the case id
. integer *      2   KEY_COUNT       | key count
. string  *     36   KEY_NAME        | generic key name
. INTEGER *      2   MY_IOSTAT       | IOSTAT FOR OPENING MEMBER
. integer *      1   IS_KEY           | IS IT A KEY VARIABLE
. INTEGER *      1   YES NO
. string  *     32   VAR_NAME        | variable name
. string  *    256   USING_KEYS      | key vars to pass to screen
. string  *     32   DB_PROC_FILE    | points to database procfile
. integer *      1   SCREENS_EXIST
. string  *    256   comstr
. INTEGER *      1   RESVAR

. ifthen ( sglobal('sirver') eq 'XS.01.20' )
.   DB_PROC_FILE = 'SIR'+ pformat( system(39), 'zzzz' ) + '4'
. elseif ( sglobal('sirver') eq 'XS.01.19' )
.   DB_PROC_FILE = 'SIR'+ pformat( system(39), 'zz' ) + '4'
. endif

. ifthen( 0 eq len( DB_PROC_FILE ) or exists( DB_PROC_FILE ) )
.   display infobox 'No DB_PROC_FILE defined.  EXITING.  CONTACT ADMIN.'
.   RETURN
. endif

. COMSTR = "set procfile " + DB_PROC_FILE  | screens go into database procfile file, not the guiprocf
. execute dbms COMSTR

. set NO (0) YES (1)

C DOES THE FAMILY SCREENS ALREADY EXISTS?  IF NOT MAKE IT.
. SCREENS_EXIST = 0
. for EACH_FAMILY = 1, SYSTEM(57)
.   ifthen( famname( EACH_FAMILY ) EQ 'SCREENS' )
.     SCREENS_EXIST = 1
.     exit for
.   endif
. end for

c create the non-existent family
. ifthen (SCREENS_EXIST EQ 0 )
<COMMENT> WRITE 'SCREENS FAMILY DID NOT EXIST'
.  compute COMSTR = 'CREATE FAMILY SCREENS'
.  execute dbms COMSTR
. endif

C DOUBLE CHECK FOR FAMILY NAME

C CHECK FOR EXISTING ALL CALL
C  ASK BEFORE OVER WRITING
C  ASK IF WANT TO APPEND

. ifthen ( nvarsc( REC_TYPE_NUM ) EQ 0 )
.   write 'no variables to create screen with '
.   RETURN
. endif

. SCREEN_PAGE = 1
. RECORD_NAME = trimlr( recname( REC_TYPE_NUM ) )
. MEMBER_NAME = 'SCREENS.' + RECORD_NAME

ifthen ( meminfo (DB_PROC_FILE + '.' + MEMBER_NAME + ':T', 1 )  > 0 ) | MEMBER ALREADY EXISTS
.  DISPLAY YNBOX "THIS WILL RE-WRITE " + MEMBER_NAME + ". CONTINUE?" RESPONSE RESVAR
.  IFTHEN (RESVAR EQ 0 )
.    DISPLAY INFOBOX "CANCELED"
.    RETURN
.  ENDIF
ENDIF


. open ( MEMBER_NAME ) dsnvar = MEMBER_NAME iostat = MY_IOSTAT  write lrecl=300 REPLACE member
. ifthen (MY_IOSTAT NE 0)
.   write 'unable to write to member.  exiting.  screen not made.  IOSTAT:' MY_IOSTAT
.   RETURN
. endif
. write ( MEMBER_NAME ) '|| Generated by Form Painter' /
                        'FORM UPDATE LABELS' /
                        '     PAGESIZE 34'
. MEMBER_LINE =         '     SUBROUTINE SCREENS.' +  RECORD_NAME + '( CASE$ KEY$1 KEY$2 KEY$3 KEY$4 KEY$5 KEY$6 ) REPLACE'  ; execute subprocedure MEMBER_WRITE
. write ( MEMBER_NAME ) 'STRING * 32 CASE$  KEY$1  KEY$2  KEY$3  KEY$4  KEY$5  KEY$6' /
                        'CALL GUIPROCF.SCREENS.INC_VARS'
. MEMBER_LINE =         'RECNUMBER# = RECNUM("' + format(REC_TYPE_NUM) + '")'
. write ( MEMBER_NAME ) MEMBER_LINE
. write ( MEMBER_NAME ) 'CALL GUIPROCF.SCREENS.INC_HEADER'

. KEY_COUNT = nkeys( REC_TYPE_NUM )

. USING_KEYS = ''
. ifthen ( dbtype ( 0 ) EQ 1  ) | If it is a CASE structured db
.   CASE_NAME = keyname( 0, 1 )
.   ifthen ( vtype( 0,  CASE_NAME  ) >= 5 )
.     write ( MEMBER_NAME ) 'INTEGER * 4 CASE#'
.     write ( MEMBER_NAME ) 'CASE# = numbr( CASE$ )'
.     USING_KEYS = USING_KEYS + ' CASE# '
.   else
.     USING_KEYS = USING_KEYS + ' CASE$ '
.   endif
.   if (KEY_COUNT > 1- dbtype(0) ) USING_KEYS = USING_KEYS + ', '  | MORE KEYS TO COME
. endif
. for EACH_KEY = 1, KEY_COUNT
.   KEY_NAME = keyname( REC_TYPE_NUM, dbtype( 0 ) + EACH_KEY )
.   ifthen ( vtype( REC_TYPE_NUM, KEY_NAME ) = 3 )
.     MEMBER_LINE = 'DATE KEY_' + format( EACH_KEY ) +
                    ' ( "' + datemap( REC_TYPE_NUM, KEY_NAME ) + '" )'
.     write ( MEMBER_NAME ) MEMBER_LINE
.     MEMBER_LINE = 'KEY_' + format( EACH_KEY ) +
                    ' = KEY$' + format( EACH_KEY )
.     write ( MEMBER_NAME ) MEMBER_LINE

.     USING_KEYS = USING_KEYS + ' KEY_' + format( EACH_KEY )

.   elseif( vtype( REC_TYPE_NUM, KEY_NAME ) = 4 )
.     MEMBER_LINE = 'TIME KEY_' + format( EACH_KEY ) +
                    ' ( "' + timemap( REC_TYPE_NUM, KEY_NAME ) + '" )'
.     write ( MEMBER_NAME ) MEMBER_LINE
.     MEMBER_LINE = 'KEY_' + format( EACH_KEY ) +
                    ' = KEY$' + format( EACH_KEY )
.     write ( MEMBER_NAME ) MEMBER_LINE
.     USING_KEYS = USING_KEYS + ' KEY_' + format( EACH_KEY )

.   elseif( vtype( REC_TYPE_NUM, KEY_NAME ) >= 5 )
.     MEMBER_LINE = 'REAL * 8 KEY#' + format( EACH_KEY )
.     write ( MEMBER_NAME ) MEMBER_LINE
.     MEMBER_LINE = 'KEY#' + format( EACH_KEY ) +
                    ' = numbr( KEY$' + format( EACH_KEY ) + ')'
.     write ( MEMBER_NAME ) MEMBER_LINE
.     USING_KEYS = USING_KEYS + ' KEY#' + format( EACH_KEY )

.   else
.     USING_KEYS = USING_KEYS + ' KEY$' + format( EACH_KEY )
.   endif
.   if (EACH_KEY < KEY_COUNT ) USING_KEYS = USING_KEYS + ', '
. end for

. ifthen ( dbtype ( 0 ) EQ 1  ) | If it is a CASE structured db
.   USING_KEYS = '     USING ( ' + USING_KEYS  + ')'
. ELSE
.   USING_KEYS = '     VIA ( "",' + USING_KEYS  + ')'
. endif
. for EACH_KEY = 1, KEY_COUNT
.   VAR_NAME = keyname( REC_TYPE_NUM, dbtype( 0 ) + EACH_KEY )
.   ifthen( vtype( REC_TYPE_NUM,  VAR_NAME  ) < 3 ) | strings
.     KEY_NAME = 'KEY$'
.   elseif( vtype( REC_TYPE_NUM,  VAR_NAME  ) < 5 ) | dates and times
.     KEY_NAME = 'KEY_'
.   else
.     KEY_NAME = 'KEY#'
.   endif
.   KEY_NAME =  KEY_NAME + format( EACH_KEY )

.   MEMBER_LINE = 'ifthen (exists (' + KEY_NAME  + ' ) eq 0 ) '
.   execute subprocedure MEMBER_WRITE
.   MEMBER_LINE = '. display infobox "Error: Key' + format(EACH_KEY) +
                  ', ' + VAR_NAME + ', is system missing."'
.   execute subprocedure MEMBER_WRITE
.   MEMBER_LINE = '. return'
.   execute subprocedure MEMBER_WRITE
.   MEMBER_LINE = 'endif'
.   execute subprocedure MEMBER_WRITE
. end for

. MEMBER_LINE = 'CALL SCREEN "' + RECORD_NAME + '"'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     AT 1, 1'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     PROMPT "' + RECORD_NAME + '"'; execute subprocedure MEMBER_WRITE
. write ( MEMBER_NAME )  USING_KEYS
. MEMBER_LINE = '     ONCALL FIRST'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     WIDTH 0'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = 'SCREEN RECORD ' + recname( REC_TYPE_NUM ); execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     NOBUTTON'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     NOAUTO'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     TITLE ( SET DIALOG TITLE "' + RECORD_NAME + '" + PAGENO + "/" + PAGES + " " + CASE$ )' ; execute subprocedure MEMBER_WRITE
| DEBUG CONTINUE FROM HERE
. IFTHEN (1 EQ 0) | CHECK FOR MEMBER AND INCLUDE IT IF IT IS THERE.
.   write ( MEMBER_NAME )  '     READ   ( CALL SCREENS.INC_PERMISSIONS )'
. ENDIF
. write ( MEMBER_NAME )  '     WRITE  ( CALL GUIPROCF.SCREENS.INC_WRITE; )'
. write ( MEMBER_NAME )  '     DELETE ( CALL GUIPROCF.SCREENS.INC_DELETE; )' /
                         'FDISPLAY TEXT (' /
                         '      fst(recdoc(RECNUMBER#, 0), recdoc(RECNUMBER#, 1), "")' /
                         '      )' /
                         '      AT 2, 4 WIDTH 83' /
                         '      FONT (BOLD ) '/
                         'FDISPLAY       TEXT (' /
                         '      MESSTEXT$' /
                         '      )' /
                         '      AT 2,90 WIDTH 42' /
                         '      FONT (BOLD ) ' / /

. DO REPEAT REP_VAR = DWHO   DSTAMP    DCCDATE  DCCWHO  DCCTIME  DCCEDITS /
            REP_COL = 1 18 35 65  82 99
.   ifthen ( vtype( REC_TYPE_NUM, 'REP_VAR' ) > 0 )
.     write ( MEMBER_NAME )  'FIELD REP_VAR' /
                              '      DATA AT 31, REP_COL WIDTH 17' /
                              '      NOLABELS' /
                              '      PROMPT VARLABEL AT 32, REP_COL WIDTH 17' /
                              '      FONT (FGROUND=C000FF )' /
                              '      READONLY' /
.   ENDIF
. END REPEAT

. SCREEN_LINE = 3 | provide space at the top of the first screen

c put keys at the top of the file
. for EACH_KEY = 1, KEY_COUNT + dbtype( 0 )
.   VAR_NAME = trim( keyname( REC_TYPE_NUM, EACH_KEY ) )
.   SCREEN_LINE = SCREEN_LINE + 1
.   write ( MEMBER_NAME )  [ 'FIELD ' + VAR_NAME ]
.   write ( MEMBER_NAME )  [ '    PROMPT VARLABEL AT ' + format(SCREEN_LINE) + ', 4 WIDTH 18' ]
.   write ( MEMBER_NAME )  [ '    DATA AT ' + format(SCREEN_LINE) +  ', 23 WIDTH 13' ]
.   write ( MEMBER_NAME )  [ '    FONT ( BOLD BGROUND=FFFF00  )' ]
.   write ( MEMBER_NAME )  [ '    LABELS AT ' + format(SCREEN_LINE) +  ', 36 WIDTH 16' ]
.   write ( MEMBER_NAME )  [ '    FONT ( BOLD BGROUND=FFFF00  )' ]
. end for


. for EACH_VAR = 1, nvarsc( REC_TYPE_NUM )
.   VAR_NAME = trim( varnamec( REC_TYPE_NUM, EACH_VAR ) )
.   if ( VAR_NAME = 'DWHO' or 'DSTAMP' or 'DCCWHO' or 'DCCEDITS' or 'DCCDATE' or 'DCCTIME' ) NEXT FOR  | HANDLED SPECIAL
.   IS_KEY = NO
.   for EACH_KEY = 1, KEY_COUNT + dbtype( 0 )
.     ifTHEN ( VAR_NAME EQ trim( keyname( REC_TYPE_NUM, EACH_KEY ) ) )
.       IS_KEY = YES
.       exit for
.     ENDIF
.   end for
.   if ( IS_KEY = YES ) next for | keys were already made at the top of the file
.   SCREEN_LINE = SCREEN_LINE + 1
.   write ( MEMBER_NAME )  [ 'FIELD ' + VAR_NAME ]
.   write ( MEMBER_NAME )  [ '      PROMPT VARLABEL AT ' + format(SCREEN_LINE) +  ', 4 WIDTH 68' ]
.   write ( MEMBER_NAME )  [ '      DATA AT ' + format(SCREEN_LINE) + ', 72 WIDTH 13' ]
.   write ( MEMBER_NAME )  [ '      LABELS AT ' + format(SCREEN_LINE) + ', 85 WIDTH 23' ]
.   ifthen ( amod( SCREEN_LINE, 29 ) eq 0 )  | page break
.     ifnotthen ( EACH_VAR = nvarsc( REC_TYPE_NUM ) ) | CHECK FOR MORE VARIABLES, IF SO: CREATE NEW PAGE
.       write ( MEMBER_NAME )  'PAGE'
.       SCREEN_LINE = 3   | reset line number to bring variables to top of new page
.       SCREEN_PAGE = SCREEN_PAGE + 1
.     endif
.   endif
. end for
. write ( MEMBER_NAME )  'FBUTTON WRITE' /
                         '      AT 1, 50 WIDTH 14' /
                         '      PROMPT "&Save"' /
                         'FBUTTON DELETE' /
                         '      AT 1, 67 WIDTH 14' /
                         '      PROMPT "Delete"' /
                         'FBUTTON EXIT' /
                         '      AT 1, 118 WIDTH 14' /
                         '      PROMPT "E&xit"' /
. ifthen ( SCREEN_PAGE > 1 )
.   write ( MEMBER_NAME )  'FBUTTON PAGEUP' /
                           '      AT 1, 84 WIDTH 14' /
                           '      PROMPT "Pg&Up"' /
                           'FBUTTON PAGEDOWN'/
                           '      AT 1, 101 WIDTH 14'/
                           '      PROMPT "Pg&Dn"' /
. endif
. write ( MEMBER_NAME )  'FBUTTON STATUS' /
                         '      AT 33, 1 WIDTH 40' /
. write ( MEMBER_NAME )  'END SCREEN'
. write ( MEMBER_NAME )  'END FORM'

. close MEMBER_NAME

C COMPILE SCREEN
. COMSTR = "CALL " + MEMBER_NAME
. EXECUTE DBMS COMSTR


subprocedure MEMBER_WRITE
. if (exists(MEMBER_LINE) EQ 0) MEMBER_LINE = '| WARNING SYSTEM MISSING MEMBERLINE!'
. write ( MEMBER_NAME )  MEMBER_LINE
end subprocedure

END SUBROUTINE




END PROCEDURE
