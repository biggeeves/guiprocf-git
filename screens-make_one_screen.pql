PROCEDURE      SCREENS.MAKE_ONE_SCREEN:T  (157612,52246)  |Last amended Apr 24, 2014,14:30:46
C MAKE ONE DATA ENTRY SCREEN THAT WORKS WITH THE MAIN DATA ENTRY GUI
C PASS THE SCREEN NUMBER YOU WANT TO MAKE

CIF EQ 1,2
SEPARATE MEMBER FOR ALL_CALLS
. write ( ALL_CALL )  'PROCEDURE      SCREENS.ALLCALL'
. for EACH_RECORD_NUM = 1,  nrecs( 0 )
.   ifthen ( nvarsc( EACH_RECORD_NUM ) > 0 )
.     RECORD_NAME = recname( EACH_RECORD_NUM )
.     write ( ALL_CALL )  'CALL SCREENS.'  RECORD_NAME
.   endif
. end for
. write ( ALL_CALL )  'END PROCEDURE'
CIF END

CIF EQ 1,2   | SHOULD BE IN AN ALL CALL OF SOME SORT
. for EACH_RECORD_NUM = 1,  nrecs( 0 )
CIF END

. SUBROUTINE MAKE_ONE_SCREEN ( REC_TYPE_NUM ) CRWARN   REPLACE
. STRING  *    256   SCREEN_NAME     | NAME OF SCREEN TO MAKE
. INTEGER *      2   REC_TYPE_NUM    | RECORD_TYPE NUMBER
. STRING  *    256   MEMBER_NAME
. string  *    256   RECORD_NAME
. INTEGER *      2   SCREEN_PAGE     | SCREEN PAGE
. INTEGER *      1   SCREEN_LINE     | LINE ON THE SCREEN
. STRING  *    256   MEMBER_LINE     | LINE TO WRITE TO THE MEMBER
. string  *     36   CASE_NAME       | Variable name of case, varname(0, 1)
. integer *      1   CASE_TYPE       | What variable type is the case id
. integer *      2   KEY_COUNT       | key count
. string  *     36   KEY_NAME       | generic key name
. INTEGER *      2   MY_IOSTAT       | IOSTAT FOR OPENING MEMBER
. integer *      1   IS_KEY           | IS IT A KEY VARIABLE
. INTEGER *      1   YES NO
. string  *     32   VAR_NAME        | variable name
. string  *    256   USING_KEYS      | key vars to pass to screen

set NO (0) YES (1)


C DOUBLE CHECK FOR FAMILY NAME

C CHECK FOR EXISTING SCREENS
C  ASK IF YOU WANT TO OVERRIDE EXITSING

C CHECK FOR EXISTING ALL CALL
C  ASK BEFORE OVER WRITING
C  ASK IF WANT TO APPEND

. ifthen ( nvarsc( REC_TYPE_NUM ) EQ 0 )
.   write 'no variables to create screen with '
.   RETURN
. endif

. SCREEN_PAGE = 1
. RECORD_NAME = trimlr( recname( REC_TYPE_NUM ) )
. SCREEN_NAME = 'SCREENS.' + RECORD_NAME + ':T'
. MEMBER_NAME = 'SCREENS.' + RECORD_NAME

. open ( MEMBER_NAME ) dsnvar = MEMBER_NAME iostat = MY_IOSTAT  write lrecl=200 REPLACE member
. ifthen (MY_IOSTAT NE 0)
.   write 'unable to write to member.  exiting.  screen not made.  IOSTAT:' MY_IOSTAT
.   RETURN
. endif
. write ( MEMBER_NAME ) '|| Generated by Form Painter' /
                        'FORM UPDATE LABELS' /
                        '     PAGESIZE 34'
. MEMBER_LINE =         '     SUBROUTINE SCREENS.' +  RECORD_NAME + '( CASE$ KEY$1 KEY$2 KEY$3 KEY$4 KEY$5 KEY$6 ) REPLACE'  ; execute subprocedure MEMBER_WRITE
. write ( MEMBER_NAME ) 'STRING * 32 CASE$  KEY$1  KEY$2  KEY$3  KEY$4  KEY$5  KEY$6' /
                        'CALL GUIPROCF.SCREENS.INC_VARS'
. write ( MEMBER_NAME ) ['RECNUMBER# = RECNUM("' + format(REC_TYPE_NUM) + '")']
. write ( MEMBER_NAME ) 'CALL GUIPROCF.SCREENS.INC_HEADER' /
                        'CALL SCREENS.INC_SUBJINFO'

. KEY_COUNT = nkeys( REC_TYPE_NUM )

. USING_KEYS = ''
. ifthen ( dbtype ( 0 ) EQ 1  ) | If it is a CASE structured db
.   CASE_NAME = keyname( 0, 1 )
.   ifthen ( vtype( 0,  CASE_NAME  ) >= 5 )
.     write ( MEMBER_NAME ) 'INTEGER * 4 CASE#'
.     write ( MEMBER_NAME ) 'CASE# = numbr( CASE$ )'
.     USING_KEYS = USING_KEYS + ' CASE# '
.   else
.     USING_KEYS = USING_KEYS + ' CASE$ '
.   endif
.   if (KEY_COUNT > 1- dbtype(0) ) USING_KEYS = USING_KEYS + ', '  | MORE KEYS TO COME
. endif
. for EACH_KEY = 1, KEY_COUNT
.   KEY_NAME = keyname( REC_TYPE_NUM, dbtype( 0 ) + EACH_KEY )
.   ifthen ( vtype( REC_TYPE_NUM, KEY_NAME ) = 3 )
.     write ( MEMBER_NAME ) ['DATE KEY' + format( EACH_KEY ) + '_ ( "' + datemap( REC_TYPE_NUM, KEY_NAME ) + '" )']
.     USING_KEYS = USING_KEYS + ' KEY' + format( EACH_KEY ) + '_'
.   elseif ( vtype( REC_TYPE_NUM, KEY_NAME ) = 4 )
.     write ( MEMBER_NAME ) ['TIME KEY' + format( EACH_KEY ) + '_ ( "' + timemap( REC_TYPE_NUM, KEY_NAME ) + '" )']
.     USING_KEYS = USING_KEYS + ' KEY' + format( EACH_KEY ) + '_'
.   elseif ( vtype( REC_TYPE_NUM, KEY_NAME ) >= 5 )
.     write ( MEMBER_NAME ) ['REAL * 8 KEY#' + format( EACH_KEY )]
.     write ( MEMBER_NAME ) ['KEY' + format( EACH_KEY ) + '# = numbr( KEY$' + format( EACH_KEY ) + ')']
.     USING_KEYS = USING_KEYS + ' KEY#' + format( EACH_KEY )
.   else
.     USING_KEYS = USING_KEYS + ' KEY$' + format( EACH_KEY )
.   endif
.   if (EACH_KEY < KEY_COUNT ) USING_KEYS = USING_KEYS + ', '
. end for

. write RECORD_NAME USING_KEYS REC_TYPE_NUM



. MEMBER_LINE = 'CALL SCREEN "' + RECORD_NAME + '"'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     AT 1, 1'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     PROMPT "' + RECORD_NAME + '"'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     USING ( ' + USING_KEYS  + ')'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     ONCALL FIRST'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     WIDTH 0'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = 'SCREEN RECORD ' + recname( REC_TYPE_NUM ); execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     NOBUTTON'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     NOAUTO'; execute subprocedure MEMBER_WRITE
. MEMBER_LINE = '     TITLE ( SET DIALOG TITLE "' + RECORD_NAME + '" + PAGENO + "/" + PAGES + " " + CASE$ )' ; execute subprocedure MEMBER_WRITE
. write ( MEMBER_NAME )  '     READ   ( CALL SCREENS.INC_PERMISSIONS )' /
                         '     WRITE  ( CALL GUIPROCF.SCREENS.INC_WRITE; )' /
                         '     DELETE ( CALL GUIPROCF.SCREENS.INC_DELETE; )' /
                         'FDISPLAY       TEXT (' /
			 '      MESSTEXT$' /
			 '      )' /
			 '      AT 2,85 WIDTH 38' /
                         '      FONT (BOLD ) ' /
                         'FDISPLAY TEXT (' /
                         '           fst(recdoc(RECNUMBER#, 0), recdoc(RECNUMBER#, 1), "")' /
                         '           )' /
                         '      AT 5, 40 WIDTH 44' /
                         '      FONT (BOLD ) '
. DO REPEAT REP_VAR = DWHO  DSTAMP  DCCWHO  DCCDATE  DCCTIME  DCCEDITS /
            REP_LINE = 1 2 3 4 5 6
.   ifthen ( vtype( REC_TYPE_NUM, 'REP_VAR' ) > 0 )
.     write ( MEMBER_NAME )  'FIELD REP_VAR' /
                              '      DATA AT REP_LINE, 105 WIDTH 13' /
                              '      NOLABELS' /
                              '      PROMPT VARLABEL AT REP_LINE, 88 WIDTH 16' /
                              '      FONT (FGROUND=C000FF )' /
                              '      READONLY' /
.   ENDIF
. END REPEAT

. SCREEN_LINE = 6 | provide space at the top of the first screen

c put keys at the top of the file
. for EACH_KEY = 1, KEY_COUNT + dbtype( 0 )
.   VAR_NAME = trim( keyname( REC_TYPE_NUM, EACH_KEY ) )
.   SCREEN_LINE = SCREEN_LINE + 1
.   write ( MEMBER_NAME )  [ 'FIELD ' + VAR_NAME ]
.   write ( MEMBER_NAME )  [ '    PROMPT VARLABEL AT ' + format(SCREEN_LINE) + ', 1 WIDTH 18' ]
.   write ( MEMBER_NAME )  [ '    DATA AT ' + format(SCREEN_LINE) +  ', 20 WIDTH 13' ]
.   write ( MEMBER_NAME )  [ '    FONT ( BOLD BGROUND=FFFF00  )' ]
.   write ( MEMBER_NAME )  [ '    LABELS AT ' + format(SCREEN_LINE) +  ', 32 WIDTH 16' ]
.   write ( MEMBER_NAME )  [ '    FONT ( BOLD BGROUND=FFFF00  )' ]
. end for


. for EACH_VAR = 1, nvarsc( REC_TYPE_NUM )
.   VAR_NAME = trim( varnamec( REC_TYPE_NUM, EACH_VAR ) )
.   if ( VAR_NAME = 'DWHO' or 'DSTAMP' or 'DCCWHO' or 'DCCEDITS' or 'DCCDATE' or 'DCCTIME' ) NEXT FOR  | HANDLED SPECIAL
.   IS_KEY = NO
.   for EACH_KEY = 1, KEY_COUNT + dbtype( 0 )
.     ifTHEN ( VAR_NAME EQ trim( keyname( REC_TYPE_NUM, EACH_KEY ) ) )
.       IS_KEY = YES
.       exit for
.     ENDIF
.   end for
.   if ( IS_KEY = YES ) next for | keys were already made at the top of the file
.   SCREEN_LINE = SCREEN_LINE + 1
.   write ( MEMBER_NAME )  [ 'FIELD ' + VAR_NAME ]
.   write ( MEMBER_NAME )  [ '      PROMPT VARLABEL AT ' + format(SCREEN_LINE) +  ', 1 WIDTH 68' ]
.   write ( MEMBER_NAME )  [ '      DATA AT ' + format(SCREEN_LINE) + ', 70 WIDTH 13' ]
.   write ( MEMBER_NAME )  [ '      LABELS AT ' + format(SCREEN_LINE) + ', 83 WIDTH 23' ]
.   ifthen ( amod( SCREEN_LINE, 29 ) eq 0 )  | page break
.     ifnotthen ( EACH_VAR = nvarsc( REC_TYPE_NUM ) ) | CHECK FOR MORE VARIABLES, IF SO: CREATE NEW PAGE
.       write ( MEMBER_NAME )  'PAGE'
.       SCREEN_LINE = 1   | reset line number to bring variables to top of new page
.       SCREEN_PAGE = SCREEN_PAGE + 1
.     endif
.   endif
. end for
. write ( MEMBER_NAME )  'FBUTTON EXIT' /
                         '      AT 1, 120 WIDTH 13' /
                         '      PROMPT "E&xit"' /
                         'FBUTTON WRITE' /
                         '      AT 2, 120 WIDTH 13' /
                         '      PROMPT "&Save"' /
                         'FBUTTON DELETE' /
                         '      AT 2, 120 WIDTH 13' /
                         '      PROMPT "Delete"' /
. ifthen ( SCREEN_PAGE > 1 )
.   write ( MEMBER_NAME )  'FBUTTON PAGEUP' /
                           '      AT 3, 120 WIDTH 6' /
                           '      PROMPT "Pg&Up"' /
                           'FBUTTON PAGEDOWN'/
                           '      AT 3, 127 WIDTH 6'/
                           '      PROMPT "Pg&Dn"' /
. endif
. write ( MEMBER_NAME )  'FBUTTON STATUS' /
                         '      AT 33, 1 WIDTH 40' /
                         'END SCREEN' /
                         'END FORM' /

. close MEMBER_NAME

C COMPILE SCREEN
c . EXECUTE DBMS ["CALL " + MEMBER_NAME ]


subprocedure MEMBER_WRITE
. if (exists(MEMBER_LINE) EQ 0) MEMBER_LINE = '| WARNING SYSTEM MISSING MEMBERLINE!'
. write ( MEMBER_NAME )  MEMBER_LINE
end subprocedure

END SUBROUTINE




END PROCEDURE
