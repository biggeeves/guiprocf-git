PROCEDURE      SCREENS.MAKE_ALL_SCREENS:T  (157612,84135)  |Last amended Apr 24, 2014,23:22:15
C CREATE DATA ENTRY SCREENS FOR ALL RECORD TYPES IN CURRENT DATABASE
C THIS LOOPS THROUGHT THE RECORD TYPES AND CALLS A SUBROUTINE TO DO THE DIRTY WORK.


PROGRAM
INTEGER * 1 SCREENS_EXIST
INTEGER * 2  EACH_RECORD_NUM
STRING  * 32 RECORD_NAME


C DOES THE FAMILY SCREENS ALREADY EXISTS?  IF NOT MAKE IT.
SCREENS_EXIST = 0
FOR EACH_FAMILY = 1, SYSTEM(57)
. IF ( FAMNAME(EACH_FAMILY) EQ 'SCREENS') SCREENS_EXIST = 1
END FOR

C DOES THE USER WANT TO CANCEL IF SCREENS ARE ALREADY IN PLACE?
IFTHEN (SCREENS_EXIST EQ 0 )
.  COMPUTE comstr = 'CREATE FAMILY SCREENS'
.  EXECUTE DBMS COMSTR
ELSE | FAMILY EXISTS
.  DISPLAY YNBOX "THIS WILL OVERRIDE MEMBERS IN THE FAMILY CALLED SCREENS. CONTINUE?" RESPONSE RESVAR
.  IFTHEN (RESVAR EQ 0 )
.    DISPLAY INFOBOX "CANCELED"
.    EXIT PROGRAM
.  ENDIF
ENDIF
write 'made it'

for EACH_RECORD_NUM = 1,  nrecs( 0 )
. if ( nvarsc( EACH_RECORD_NUM ) EQ 0 ) NEXT FOR
. RECORD_NAME = recname( EACH_RECORD_NUM )
. EXECUTE SUBROUTINE GUIPROCF.SCREENS.MAKE_ONE_SCREEN ( EACH_RECORD_NUM )
end for

END PROGRAM
END PROCEDURE
