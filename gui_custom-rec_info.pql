PROCEDURE      GUI_CUSTOM.REC_INFO:T  (157655,30639)  |Last amended Jun 06, 2014,08:30:39
c outputs to gui item 1 row for each record in specified record type.
c Example:   IN SIR014.GUI_CUSTOM.CASE_INFO WRITE ONE LINE OF CODE
c            call GUIPROCF.GUI_CUSTOM.REC_INFO

CALL GUIPROCF.GUI_CUSTOM.SET_LOCAL_CASE_TYPE  | make sure we have the global value for processing case ids correctly

subroutine GUI_CUSTOM.REC_INFO (THIS_CASEID REC_TYPE_NUM ITEM_NUMBER) returning (PROCEED) replace


string  *  32   THIS_CASEID      | incoming case id value is always a string
string  *  32   LOCAL_CASE_ID$
integer *   4   LOCAL_CASE_ID#
INTEGER *   1   TEMP_VAR
integer *   2   ITEM_NUMBER
integer *   1   PROCEED
string  * 300   GEN_STR1
integer *   2   REC_TYPE_NUM
integer *   1   REC_TYPE_COUNT


LOCAL_CASE_ID$ = THIS_CASEID
LOCAL_CASE_ID# = numbr(THIS_CASEID)

PROCEED = 1

if(exists (LOCAL_CASE_ID$) EQ 0 ) RETURN

if(sglobal('comment') eq '.')  write 'IN GUI_CUSTOM.REC_INFO: ' LOCAL_CASE_ID$  REC_TYPE_NUM  | in the subroutine, the global comment might not be set during the backup routine and will throw an error if the line starts with <comment>

if(validate(0, VARNAMEC(0, 1), LOCAL_CASE_ID$) <> 0) DISPLAY INFOBOX 'NOT A VALID ID'; RETURN

PROCEED = 1

CIF EQ 1, 0<LOCAL_CASE_TYPE>    | STRING.  TREAT EVERYTHING ELSE AS NUMERIC
. OLD CASE IS LOCAL_CASE_ID$ lock=2
CIF FALSE
. OLD CASE IS LOCAL_CASE_ID# lock=2
CIF END
.   GEN_STR1 = '<body readonly="true"><font color="#336af3" size="+2" face="Arial"><br>'
.   append line ITEM_NUMBER, GEN_STR1 HTML
.   PROCEED = 1
. DO REPEAT RECX = <GREC1>
                <GREC2>
                <GREC3>
                <GREC4>
.   ifthen (REC_TYPE_NUM EQ RECX)
.     ifthen(count(RECX) EQ 0)
.       append line ITEM_NUMBER, 'No Records' HTML
.     else
.       GEN_STR1 = 'Record Summary<BR><font color="#404040">'
.       append line  ITEM_NUMBER, GEN_STR1 HTML
.       ifthen (nkeys(RECX) EQ 0)
.         process rec RECX
.           GEN_STR1 = 'Created: '  | break is added to restore black small font
.           IF(EXISTS(DSTAMP) EQ 1)   GEN_STR1 = 'Created ' + DSTAMP
.           IF(EXISTS(DWHO) EQ 1)     GEN_STR1 = GEN_STR1 + ' by ' + DWHO
.           GEN_STR1 = GEN_STR1 + '<br>Last Edit: '
.           IF(EXISTS(DCCDATE) EQ 1)  GEN_STR1 = GEN_STR1 + ' on ' + DCCDATE
.           IF(EXISTS(DCCTIME) EQ 1)  GEN_STR1 = GEN_STR1 + ' at ' + DCCTIME
.           IF(EXISTS(DCCWHO) EQ 1)   GEN_STR1 = GEN_STR1 + ' by ' + DCCWHO
.           append line  ITEM_NUMBER, '<BR>' + GEN_STR1 HTML
.         end rec
.       else
.         REC_TYPE_COUNT = 0
.         process rec RECX
.           REC_TYPE_COUNT = REC_TYPE_COUNT + 1
.           GEN_STR1 = 'Row' + FORMAT(REC_TYPE_COUNT) +': '
.           for EACH_KEY = 1 + dbtype(0), nkeys(RECX) +  dbtype(0)
.             KEYVNAME__4 = pack(keyname(RECX, EACH_KEY))
.             STRING_VARGET = trimlr(varget(KEYVNAME__4))
.             GEN_STR1 = GEN_STR1 + STRING_VARGET
.             if (EACH_KEY lt nkeys(RECX) +  dbtype(0)) GEN_STR1 = GEN_STR1 +', '
.           end for
.           append line  ITEM_NUMBER, '<br>' + GEN_STR1 HTML
.         end rec
.       endif
.     endif
.   endif
. END REPEAT

. END CASE IS
. TEMP_VAR = scrollto (ITEM_NUMBER, 1)
end subroutine
END PROCEDURE
